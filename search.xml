<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/_posts/23/"/>
      <url>/_posts/23/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/22/"/>
      <url>/_posts/22/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/21/"/>
      <url>/_posts/21/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/1/"/>
      <url>/_posts/1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/20/"/>
      <url>/_posts/20/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/19/"/>
      <url>/_posts/19/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/17/"/>
      <url>/_posts/17/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/18/"/>
      <url>/_posts/18/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/16/"/>
      <url>/_posts/16/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/14/"/>
      <url>/_posts/14/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/13/"/>
      <url>/_posts/13/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/28/"/>
      <url>/_posts/28/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/24/"/>
      <url>/_posts/24/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/29/"/>
      <url>/_posts/29/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/25/"/>
      <url>/_posts/25/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/27/"/>
      <url>/_posts/27/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/15/"/>
      <url>/_posts/15/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/10/"/>
      <url>/_posts/10/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/26/"/>
      <url>/_posts/26/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/9/"/>
      <url>/_posts/9/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/8/"/>
      <url>/_posts/8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/7/"/>
      <url>/_posts/7/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/6/"/>
      <url>/_posts/6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/5/"/>
      <url>/_posts/5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/4/"/>
      <url>/_posts/4/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/3/"/>
      <url>/_posts/3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/2/"/>
      <url>/_posts/2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/1/"/>
      <url>/_posts/1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/12/"/>
      <url>/_posts/12/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/11/"/>
      <url>/_posts/11/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/4/"/>
      <url>/_posts/4/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/1/"/>
      <url>/_posts/1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/3/"/>
      <url>/_posts/3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/2/"/>
      <url>/_posts/2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/9/"/>
      <url>/_posts/9/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello Worldd</title>
      <link href="/_posts/42111/"/>
      <url>/_posts/42111/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>单片机的启动流程</title>
      <link href="/_posts/30383/"/>
      <url>/_posts/30383/</url>
      
        <content type="html"><![CDATA[<h1 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h1><ol><li><p><strong>上电或复位</strong>: 芯片通电或RESET引脚被拉低。</p></li><li><p><strong>读取BOOT引脚</strong>: 硬件逻辑在复位信号的上升沿锁存 BOOT0 和 BOOT1 引脚的电平状态。</p></li><li><p><strong>执行内存重映射</strong>（M3&#x2F;M4才重映射，M7没有重映射）：</p><ul><li>如果 BOOT0&#x3D;0，内部总线矩阵将主闪存（0x08000000）的地址重映射到 0x00000000。</li><li>如果 BOOT0&#x3D;1, BOOT1&#x3D;0，将系统存储器（0x1FFFF000）重映射到 0x00000000。</li><li>如果 BOOT0&#x3D;1, BOOT1&#x3D;1，将SRAM（0x20000000）重映射到 0x00000000。</li></ul></li><li><p><strong>CPU开始执行</strong>：<br>CPU的PC指针指向 0x00000000，开始它的生命周期。它首先从 0x00000000 读取栈顶指针（MSP）的初始值，并加载到SP寄存器。然后从 0x00000004 读取复位处理函数（Reset_Handler）的地址，并加载到PC寄存器。</p><blockquote><p>这段描述适用全部模式：Flash、System Memory、SRAM</p></blockquote></li><li><p><strong>运行软件程序</strong>：</p><ul><li><strong>主闪存模式</strong>：CPU开始执行Reset_Handler，在回调函数中分别执行SystemInit和__main，最后执行main()函数。</li><li><strong>系统存储器模式</strong>：CPU开始执行ST官方的ISP Bootloader中的Reset Handler，在回调函数中做初始化处理后，官方的ISP程序运行，等待通过串口等接收新固件（执行bootloader）。</li><li><strong>SRAM模式</strong>：CPU开始执行0x00000004指向的函数地址下的程序（若用户有将程序拷贝或者是通过写SRAM的方式编写程序，则可正常运行；若SRAM为空，则CPU会触发硬件错误（HardFault）。</li></ul></li></ol><h1 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h1><p>MCU触发了复位事件后，芯片内部的硬件逻辑会检测BOOT0和BOOT1引脚是高电平还是低电平，根据两个BOOT脚的高低电平组合，将不同的物理存储器的起始地址重映射到0x00000000这个地址上。</p><p>紧接着CPU会从0x00000000执行程序，CPU会先将PC指针指向0x00000000，将该地址存放的栈顶指针MSP的初始值取出并加载到CPU寄存器SP中，然后偏移4个字节，将0x00000004地址下存放的复位处理函数Reset_Handler地址取出并加载到CPU寄存器PC中。</p><p>然后CPU就开始执行Reset_Handler函数下的程序，在几种模式下，主要是主闪存模式（即BOOT0为0的模式），CPU开始执行程序Reset_Handler（虚函数），默认为执行<code>system_stm32f10x.c</code>文件下的SystemInit()函数，这个函数主要负责最基本的硬件初始化，如配置系统时钟。</p><p>紧接着执行C库入口函数__main，在该函数下会建立一个符合C语言标准的程序执行环境，包括：分散加载初始化、复制.data段、清零.bss段、C&#x2F;C++库初始化、堆初始化、IO初始化、FPU初始化、调用C++静态构造函数。处理完这些就会调用用户编写的main()函数了。</p><h2 id="main-的具体工作"><a href="#main-的具体工作" class="headerlink" title="__main()的具体工作"></a>__main()的具体工作</h2><table><thead><tr><th align="left">步骤</th><th align="left">任务</th><th align="left">目标</th><th align="left">涉及内存区域</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">分散加载初始化</td><td align="left">建立正确的内存数据映像</td><td align="left">.data, .bss (SRAM)</td></tr><tr><td align="left">1.1</td><td align="left">复制.data段</td><td align="left">将Flash中的初始值赋给SRAM中的全局&#x2F;静态变量</td><td align="left">.data</td></tr><tr><td align="left">1.2</td><td align="left">清零.bss段</td><td align="left">确保未初始化的全局&#x2F;静态变量为0</td><td align="left">.bss</td></tr><tr><td align="left">2</td><td align="left">C&#x2F;C++库初始化</td><td align="left">使标准库函数可用</td><td align="left">Heap, Stack (SRAM)</td></tr><tr><td align="left">2.1</td><td align="left">初始化堆</td><td align="left">为malloc()等动态内存分配做准备</td><td align="left">Heap</td></tr><tr><td align="left">2.2</td><td align="left">初始化I&#x2F;O</td><td align="left">为printf()等函数准备底层接口</td><td align="left">-</td></tr><tr><td align="left">2.3</td><td align="left">初始化FPU</td><td align="left">使能浮点运算单元(如果需要)</td><td align="left">-</td></tr><tr><td align="left">2.4</td><td align="left">调用C++静态构造函数</td><td align="left">正确构造全局C++对象</td><td align="left">-</td></tr><tr><td align="left">3</td><td align="left">调用main()</td><td align="left">将控制权移交给用户代码</td><td align="left">Stack</td></tr><tr><td align="left">4</td><td align="left">处理main()返回</td><td align="left">提供一个确定的程序终止行为</td><td align="left">-</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> ARM架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存布局</title>
      <link href="/_posts/20977/"/>
      <url>/_posts/20977/</url>
      
        <content type="html"><![CDATA[<blockquote><p>建议在阅读本文章之前先阅读这篇文章： <a href="http://localhost:4000/_posts/59193">程序的编译、链接过程</a></p></blockquote><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ol><li><strong>Flash (ROM&#x2F;Program Memory)</strong>：存储程序代码和常量。</li><li><strong>RAM (Data Memory)</strong>：存储运行时的变量（全局、静态、局部）、堆栈数据。</li><li><strong>链接器脚本 (Linker Script, .ld 文件)</strong>：<br>告诉链接器如何将汇编器生成的各个目标文件中的“段”组合起来，最终映射到物理的 Flash 和 RAM 地址空间。</li><li><strong>启动代码 (Startup Code)</strong>：在 main 函数执行之前运行的初始化代码，负责关键的硬件初始化和最关键的内存初始化（初始化 .data 段，清零 .bss 段，设置堆栈指针）。</li></ol><h1 id="主要的内存段"><a href="#主要的内存段" class="headerlink" title="主要的内存段"></a>主要的内存段</h1><p><img src="/../../img/ARM%E6%9E%B6%E6%9E%84/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80RAM&ROM.png" alt="各个段在内存中的示意图（箭头代表增长方向）"></p><h2 id="1-text-代码段"><a href="#1-text-代码段" class="headerlink" title="1. .text (代码段)"></a>1. .text (代码段)</h2><p><strong>作用</strong>：存储程序的可执行代码（机器指令）</p><p><strong>存储位置</strong>：Flash (ROM)。因为代码是只读的，并且需要掉电后保留。</p><p><strong>实现</strong>：编译器将 C&#x2F;C++&#x2F;汇编代码编译成机器指令</p><ul><li>汇编器&#x2F;编译器将这些指令放入文件的 .text 段</li><li>链接器根据链接脚本将所有目标文件的 .text 段合并，并定位到 Flash 的起始地址（通常是 0x08000000 或类似地址）</li><li>上电复位后，CPU 从 Flash 的 .text 段中取指令执行</li></ul><h2 id="2-data-已初始化数据段"><a href="#2-data-已初始化数据段" class="headerlink" title="2. .data (已初始化数据段)"></a>2. .data (已初始化数据段)</h2><p><strong>作用</strong>：存储已初始化的全局变量和静态变量（包括函数内部的静态变量）。这些变量在程序开始运行时就有一个明确的非零初始值。</p><p><strong>存储位置</strong>：</p><ul><li>初始值存储在 Flash (ROM)：编译器在编译时知道这些变量的初始值，所以这些初始值被当作常量数据存储</li><li>运行时这些变量会被复制到 RAM 中（由启动代码在 main() 执行前完成）</li></ul><p><strong>实现 (关键点)</strong>：</p><ul><li>编译器为每个已初始化的全局&#x2F;静态变量预留 RAM 空间</li><li>编译器将这些变量的初始值提取出来，放入一个特殊的 .data 段（这个 .data 段最终会放在 Flash 中）</li><li>链接脚本做两件重要的事情：<ol><li>定义 .data 段在 RAM 中的运行时起始地址 (_sdata) 和结束地址 (_edata)</li><li>定义 .data 段的初始值在 Flash 中的存储位置 (_sidata)</li></ol></li><li>启动代码 (核心任务之一)：<ul><li>在 main() 执行前，启动代码负责将 Flash 中 _sidata 地址开始的 .data 段初始值数据，复制到 RAM 中 _sdata 地址开始的区域</li><li>复制长度是 _edata - _sdata</li><li>复制完成后，RAM 中的这些变量就有了程序设定的初始值</li></ul></li></ul><p><strong>关键特性</strong>：需要初始化（非零初始值），占用 Flash (存初始值) 和 RAM (存变量本身) 两种空间。启动时必须从 Flash 复制到 RAM。</p><h2 id="3-bss-未初始化数据段"><a href="#3-bss-未初始化数据段" class="headerlink" title="3. .bss (未初始化数据段)"></a>3. .bss (未初始化数据段)</h2><p><strong>作用</strong>：存储未初始化或显式初始化为 0 的全局变量和静态变量。</p><p><strong>存储位置</strong>：RAM。因为这些变量在程序开始运行时没有有效值（或要求为 0），不需要在 Flash 中存储任何初始数据（除了知道它的大小）。</p><p><strong>实现 (关键点)</strong>：</p><ul><li>编译器为每个未初始化或初始化为 0 的全局&#x2F;静态变量预留 RAM 空间</li><li>编译器将这些变量放入 .bss 段。注意：.bss 段本身在最终的程序镜像（烧写到 Flash 的 .bin&#x2F;.hex 文件）中不占据任何实际字节空间！它只记录需要预留多少 RAM 并将其初始化为 0。</li><li>链接器脚本定义 .bss 段在 RAM 中的起始地址 (_sbss) 和结束地址 (_ebss)</li><li>启动代码 (核心任务之二)：<ul><li>在 main() 执行前，启动代码负责将 RAM 中从 _sbss 到 _ebss 的区域清零</li><li>清零长度是 _ebss - _sbss</li></ul></li></ul><p><strong>关键特性</strong>：初始值为零（或未初始化），只占用 RAM 空间，在 Flash 中不存储实际数据（只记录大小）。启动时必须清零。</p><h2 id="4-rodata-段-只读数据段"><a href="#4-rodata-段-只读数据段" class="headerlink" title="4. .rodata 段 (只读数据段)"></a>4. .rodata 段 (只读数据段)</h2><p><strong>作用</strong>：存储常量数据，程序运行期间不会被修改。</p><p><strong>存储位置</strong>：Flash (ROM)。因为是只读的。</p><p><strong>实现</strong>：</p><ul><li>编译器将常量放入 .rodata 段</li><li>链接器将所有 .rodata 段合并并定位到 Flash 的某个区域（通常在 .text 段之后）</li><li>程序运行时直接从 Flash 中读取这些常量数据。有些单片机架构（如 Harvard）不能直接从 Flash 执行数据访问，可能需要特殊指令或临时复制到 RAM，但 .rodata 本身的目标位置是 Flash</li></ul><p><strong>关键特性</strong>：只读，存储在 Flash，不占用 RAM。CPU 直接（或通过特殊方式）从 Flash 读取。</p><h2 id="5-stack（栈区）"><a href="#5-stack（栈区）" class="headerlink" title="5. stack（栈区）"></a>5. stack（栈区）</h2><p><strong>作用</strong>：</p><ul><li>存储局部变量（非静态）</li><li>存储函数调用时的返回地址</li><li>存储函数参数</li><li>保存函数调用前后的寄存器现场</li></ul><p><strong>存储位置</strong>：RAM。需要快速读写。</p><p><strong>实现</strong>：</p><ul><li>通常由链接脚本定义栈的起始地址（栈顶 _estack，通常是 RAM 的最高地址）和大小</li><li>启动代码 (核心任务之三)：设置栈指针寄存器 (SP) 指向链接脚本定义的栈顶地址 _estack</li><li>运行时由 CPU 硬件自动管理（PUSH&#x2F;POP 指令）。函数调用时，局部变量空间在栈上分配；函数返回时，空间自动释放</li><li>栈通常从高地址向低地址增长</li></ul><h2 id="6-heap（堆区）"><a href="#6-heap（堆区）" class="headerlink" title="6. heap（堆区）"></a>6. heap（堆区）</h2><p><strong>作用</strong>：存储动态分配的内存（通过 malloc(), calloc(), new 等分配）</p><p><strong>存储位置</strong>：RAM。需要动态管理。</p><p><strong>实现</strong>：</p><ul><li>链接脚本定义堆的起始地址（通常是 .bss 段结束之后 _end）和大小（_heap_end - _heap_start）</li><li>通常需要实现一个堆内存管理器（如 malloc&#x2F;free 的实现，可能是 newlib 等 C 库提供的，或自定义的）。这个管理器负责在定义的堆区域内分配和回收内存块</li><li>堆通常从低地址向高地址增长（与栈相反），两者在 RAM 中间区域相遇</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th align="left">段名</th><th align="left">存储内容</th><th align="left">主要存储位置</th><th align="left">关键初始化动作(启动代码)</th><th align="left">占用空间类型</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">.text</td><td align="left">程序代码(指令)</td><td align="left">Flash</td><td align="left">无(CPU直接执行)</td><td align="left">Flash</td><td align="left">只读</td></tr><tr><td align="left">.data</td><td align="left">已初始化的全局&#x2F;静态变量</td><td align="left">RAM</td><td align="left">从Flash复制初始值到RAM</td><td align="left">Flash(值)+RAM(变量)</td><td align="left">启动时必须复制</td></tr><tr><td align="left">.bss</td><td align="left">未初始化的全局&#x2F;静态变量(0)</td><td align="left">RAM</td><td align="left">将RAM区域清零</td><td align="left">RAM</td><td align="left">不占Flash空间，启动时必须清零</td></tr><tr><td align="left">.rodata</td><td align="left">常量数据</td><td align="left">Flash</td><td align="left">无(程序直接从Flash读取)</td><td align="left">Flash</td><td align="left">只读</td></tr><tr><td align="left">stack</td><td align="left">局部变量、返回地址、参数等</td><td align="left">RAM</td><td align="left">设置栈指针(SP)</td><td align="left">RAM</td><td align="left">自动管理，向下增长，溢出危险</td></tr><tr><td align="left">heap</td><td align="left">动态分配的内存</td><td align="left">RAM</td><td align="left">初始化堆管理器(可选)</td><td align="left">RAM</td><td align="left">程序员管理(malloc&#x2F;free)，向上增长，碎片风险</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> ARM架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM架构 </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译过程</title>
      <link href="/_posts/59193/"/>
      <url>/_posts/59193/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要了解编译原理"><a href="#为什么要了解编译原理" class="headerlink" title="为什么要了解编译原理"></a>为什么要了解编译原理</h1><p>在嵌入式开发的世界里，处理器平台和软件生态呈现碎片化、多样化的特点。不同的嵌入式系统往往采用更灵活的配置：不同的CPU平台、不同大小的存储、不同的启动方式。因此，我们不仅要编写代码，还需要考虑将程序代码”烧”写到什么地方、加载到内存什么位置、如何执行——我们必须理解代码从源文件到在特定内存地址运行的完整历程，才能根据硬件平台的差异灵活地完成软件层面的编译优化和配置。</p><h1 id="编译的大概过程"><a href="#编译的大概过程" class="headerlink" title="编译的大概过程"></a>编译的大概过程</h1><p>编译就是将C程序中定义的函数、变量分类后，分别放置在可执行文件的代码段、数据段和BSS段中；程序中定义的字符串、printf函数打印的字符串常量则放置在只读数据段(.rodata)中。</p><p><img src="/../../img/ARM%E6%9E%B6%E6%9E%84/%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.png" alt="程序的编译、链接过程"></p><p>编译过程主要包含以下几个步骤：</p><ol><li><strong>预处理器</strong>：将源文件main.c经过预处理变为main.i</li><li><strong>编译器</strong>：将预处理后的main.i编译为汇编文件main.s</li><li><strong>汇编器</strong>：将汇编文件main.s编译为目标文件main.o</li><li><strong>链接器</strong>：将各个目标文件main.o、fun.o等链接成可执行文件a.out</li></ol><p><strong>注意</strong>：汇编器生成的目标文件是可重定位的目标文件，本身不可执行，需要经过链接器的链接、重定位之后才能运行。</p><h1 id="编译的具体过程"><a href="#编译的具体过程" class="headerlink" title="编译的具体过程"></a>编译的具体过程</h1><h2 id="预处理（预处理器）"><a href="#预处理（预处理器）" class="headerlink" title="预处理（预处理器）"></a>预处理（预处理器）</h2><p>预处理过程是在编译源程序之前，先处理源文件中的各种预处理命令。编译器不识别预处理指令，如果在编译前不先处理这些预处理命令，编译器会报错。预处理主要包括以下操作：</p><ul><li><strong>头文件展开</strong>：将<code>#include</code>包含的头文件内容展开到当前位置</li><li><strong>宏展开</strong>：展开所有的宏定义，并删除<code>#define</code>指令</li><li><strong>条件编译</strong>：根据宏定义条件，选择要参与编译的分支代码，其余分支丢弃</li><li><strong>删除注释</strong>：移除代码中的注释内容</li><li><strong>添加行号和文件名标识</strong>：编译过程中根据需要显示这些信息</li><li><strong>保留<code>#pragma</code>命令</strong>：该命令会在程序编译时指示编译器执行一些特定行为</li></ul><h2 id="编译（编译器、汇编器）"><a href="#编译（编译器、汇编器）" class="headerlink" title="编译（编译器、汇编器）"></a>编译（编译器、汇编器）</h2><p>编译阶段主要分为两步：</p><ol><li><strong>编译器</strong>调用一系列解析工具分析C代码，将C源文件编译为汇编文件</li><li><strong>汇编器</strong>将汇编文件汇编成可重定位的目标文件</li></ol><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>C源文件到汇编文件的转换，实际上是将C文件中的程序代码块、函数转换为汇编程序中的代码段，将C程序中的全局变量、静态变量、常量转换为汇编程序中的数据段、只读数据段。</p><p>总体来说，编译过程分为以下六步：</p><ol><li><strong>词法分析</strong>：将源程序分解为一系列不能再分解的记号单元（token）</li><li><strong>语法分析</strong>：对token序列进行解析，构建语法上正确的语法树</li><li><strong>语义分析</strong>：检查语法分析输出的表达式、语句是否存在语义错误（如类型不匹配、未声明变量等）</li><li><strong>中间代码生成</strong>：将语法树转化为中间代码，中间代码是一维线性序列结构，类似伪代码（与平台无关）</li><li><strong>汇编代码生成</strong>：参考ARM指令集，根据ATPCS规则分配寄存器，将中间代码翻译成ARM汇编程序</li><li><strong>目标代码生成</strong>：优化汇编代码，生成最终的目标代码</li></ol><h3 id="汇编过程"><a href="#汇编过程" class="headerlink" title="汇编过程"></a>汇编过程</h3><p>汇编过程是使用汇编器将前一阶段生成的汇编文件翻译成目标文件。汇编器的主要工作是参考指令集架构（例如ARM Cortex-M的Thumb指令集），将汇编代码翻译成对应的二进制指令，同时生成必要的信息，以section的形式组装到目标文件中，供后续链接过程使用。</p><p>汇编器处理过后的.o文件是不可执行的，属于可重定位目标文件，需要经过链接器的重定位、链接之后，才能组装成可执行的目标文件。</p><h2 id="符号与重定位的概念"><a href="#符号与重定位的概念" class="headerlink" title="符号与重定位的概念"></a>符号与重定位的概念</h2><p>编译器在将源文件翻译成可重定位目标文件的过程中，会将不同的函数编译成二进制指令后，从零地址开始依次将每个函数的指令序列存放到代码段中，每个函数的入口地址也就从零地址开始依次往后偏移。因此，在每个可重定位目标文件中，函数或变量的地址其实就是它们在文件中相对于零地址的偏移。</p><p>然而，在链接过程中，链接器将各个目标文件组装在一起时，各个目标文件的参考起始地址会发生变化，因此目标文件内的函数或变量的地址也需要随之更新，否则我们无法通过函数名引用函数、通过变量名引用变量。这个过程称为<strong>重定位</strong>。</p><p>一个文件中的所有符号（无论是函数名还是变量名），无论其是否需要重定位，汇编器都会收集起来，生成一个符号表，以section的形式添加到每一个可重定位目标文件中。在整个编译过程中，符号表主要用来保存源程序中各种符号的信息，包括符号的地址、类型、占用空间的大小等。符号表本质上是一个结构体数组，每个符号都有符号值和类型。</p><p>编译器是以C源文件为单位编译程序的。如果在一个C源文件中引用了在其他文件中定义的函数或全局变量，只要在调用之前进行声明，编译器就会认为这些符号可能在其他文件或库中定义，在编译阶段暂时不会报错。在链接过程中，链接器会尝试在其他文件或库中查找这些符号的定义，如果找不到才会报错（链接错误）。</p><p>编译器在给每个目标文件生成符号表时，如果在当前文件中没有找到符号的定义，也会将这些符号搜集在一起并保存到一个单独的符号表中，以待后续填充，这个符号表就是<strong>重定位符号表</strong>。重定位表中的符号所关联的地址，在后续链接过程中经过重定位后，会更新为新的实际地址。</p><blockquote><p>总结一下上面说的<br>在C项目的编译过程中，编译器以C源文件为单位，将一个个C文件翻译成对应的目标文件。每个目标文件都由代码段、数据段、BSS段、符号表等section组成。这些section从目标文件的零偏移地址开始按顺序排放，每个段中的符号相对于零地址的偏移，就是每个符号的地址，这样程序中定义的变量、函数名等就有了一个暂时的地址。<br>在链接过程中，这些目标文件中的各个section会重新拆分组装，每个section的起始参考地址都会发生变化，导致每个section中定义的函数、全局变量等符号的地址也需要随之修改，这个过程就是重定位。</p></blockquote><h2 id="链接（链接器）"><a href="#链接（链接器）" class="headerlink" title="链接（链接器）"></a>链接（链接器）</h2><p>链接主要分为三个过程：<strong>分段组装</strong>、<strong>符号决议</strong>、<strong>重定位</strong>。</p><h3 id="分段组装"><a href="#分段组装" class="headerlink" title="分段组装"></a>分段组装</h3><p>链接器将编译器生成的各个可重定位目标文件重新分解组装：将各个目标文件的代码段放在一起，作为最终可执行文件的代码段；将各个目标文件的数据段放在一起，作为可执行文件的数据段。其他section也会按照同样的方法进行组装，最终生成可执行文件的雏形。</p><p>链接器会在可执行文件中创建一个全局符号表，收集各个目标文件符号表中的符号并统一存放。此时，可执行文件中的所有符号都有了自己的地址，但这些地址仍然是原来在各个目标文件中的地址（即相对于零地址的偏移）。</p><p>链接生成的可执行文件最终要被加载到内存中执行，因此需要指定加载到内存中的位置。通常，程序在链接时需要指定一个链接起始地址，这个地址一般就是程序要加载到内存中的地址。在链接过程中，各个段在可执行文件中的先后组装顺序也需要考虑，可执行程序的入口地址部分通常会放在前面。</p><p>要指定程序的链接地址和各个段的组装顺序，可以通过<strong>链接脚本</strong>实现。链接脚本本质上是一个脚本文件，不仅规定了各个段的组装顺序、起始地址、位置对齐等信息，还详细描述了输出的可执行文件格式、运行平台、入口地址等信息。链接器根据链接脚本定义的规则组装可执行文件，并将这些信息以section的形式保存到可执行文件的ELF Header中。</p><h3 id="符号决议"><a href="#符号决议" class="headerlink" title="符号决议"></a>符号决议</h3><p>链接器允许一个项目中出现多个弱符号共存。在程序编译期间，编译器分析每个文件中未初始化的全局变量时，不知道该符号在链接阶段是被采用还是被丢弃，因此未初始化的全局变量并没有直接放置在BSS段中，而是将这些弱符号放到一个叫作COMMON的临时块中，在符号表中用未定义的COMMON标记，并且在目标文件中不分配存储空间。</p><p>在链接期间，链接器会比较多个文件中的弱符号，选择占用空间最大的那个作为可执行文件中的最终符号。此时，弱符号的大小已经确定，并被直接放到可执行文件的BSS段中。</p><p>与强符号、弱符号对应的，还有强引用、弱引用的概念。在程序中，我们可以定义多个函数和变量，变量名和函数名都是符号，这些符号的本质（符号值）其实就是地址。在另一个文件中，我们可以通过函数名调用函数，通过变量名访问变量。这种通过符号调用函数或访问变量的行为通常称为引用（reference），强符号对应强引用，弱符号对应弱引用。</p><p>在程序链接过程中，若对一个符号的引用为强引用，链接时找不到其定义，链接器将会报未定义错误；若对一个符号的引用为弱引用，链接时找不到其定义，链接器不会报错，也不会影响最终可执行文件的生成。可执行文件在运行时如果仍然找不到该符号的定义才会报错。</p><h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>经过符号决议，我们解决了链接过程中多文件符号冲突的问题。此时，可执行文件的符号表中的每个符号虽然都已确定，但符号表中的符号值（即每个函数、全局变量的地址）仍然是原来各个目标文件中的值，基于零地址的偏移。而链接器将各个目标文件重新分解组装后，各个段的起始地址都已发生变化。</p><p>程序重新分解组装后，无论是代码段还是数据段，各个符号的真实地址都发生了变化。因此，需要修改全局符号表中这些符号的值，将它们的真实地址更新到符号表中。修改完毕后，当我们通过符号引用调用函数或访问变量时，就能找到它们在内存中的真实地址了。</p><p>链接器如何知道哪些符号需要重定位呢？在各个目标文件中，有一个专门的重定位表，用于记录各个文件中需要重定位的符号。重定位的核心工作就是修正指令中的符号地址，这是链接过程中的最后一步，也是最核心、最重要的一步，前面的操作实际上都是为这一步服务的。</p><p>在编译阶段，编译器将各个C源文件生成目标文件时，遇到未定义的符号一般不会报错，而是认为这些符号可能在其他地方定义。只有在链接阶段，链接器在其他地方找不到该符号的定义时，才会报链接错误。编译器在编译阶段会搜集这些未定义的符号，生成一个重定位表，用于告诉链接器：”这些符号在文件中被引用，但在本文件中没有找到定义，可能在其他文件或库中定义，我先不报错，你链接的时候找找看”。</p><p>无论是代码段还是数据段，只要该段中有需要重定位的符号，编译器都会生成一个重定位表与其对应，如.rel.text（代码段重定位表）或.rel.data（数据段重定位表）。这些重定位表记录了各个段中需要重定位的符号，并以section的形式保存在各个目标文件中。</p><p>至此，整个链接过程就结束了，我们跟踪的整个编译流程也就完成了。最终生成的文件就是一个可执行目标文件。</p>]]></content>
      
      
      <categories>
          
          <category> ARM架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM架构 </tag>
            
            <tag> 编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过点灯学习C的面向对象编程思想</title>
      <link href="/_posts/64580/"/>
      <url>/_posts/64580/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象思想是什么？"><a href="#面向对象思想是什么？" class="headerlink" title="面向对象思想是什么？"></a>面向对象思想是什么？</h1><p>有的人说C语言是一门面向过程的编程语言，但是面向过程只是一种设计思想，而不是某种语言的私有财产。那什么是<strong>面向过程</strong>思想，什么是<strong>面向对象</strong>思想？<br><strong>面向过程</strong>专注于“先A，再B，然后C”的流程，适合解决线性的任务。<br><strong>面向对象</strong>专注于“谁？什么状态？能干什么？”，适合复杂系统，例如linux内核。</p><h1 id="为什么我们要学习面向对象思想？"><a href="#为什么我们要学习面向对象思想？" class="headerlink" title="为什么我们要学习面向对象思想？"></a>为什么我们要学习面向对象思想？</h1><p>你有没有过这种体验？读别人写的C语言项目，跟着一个函数跳来跳去，数据传来传去，改一个结构要动十个文件… 感觉自己不是在读代码，而是在走迷宫；<strong>或者</strong>当你自己写一个稍大的程序时，变量越加越多，函数越改越乱，到最后连自己都理不清。这通常不是C语言的错，而是我们被“一步一步来”的面向过程思维框住了。<br><strong>面向对象思想</strong>可以帮助我们把复杂系统拆分成职责清晰的模块，减少函数跳转和全局状态的传播，使代码更易读、可维护并且便于扩展。<br>下面本文将从介绍C语言如何运用<strong>结构体、函数指针</strong>实现面向对象编程的核心理念——<strong>抽象、封装、继承与多态</strong>。</p><h1 id="面向对象的四大基本特性"><a href="#面向对象的四大基本特性" class="headerlink" title="面向对象的四大基本特性"></a>面向对象的四大基本特性</h1><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>我们可以对现实存在的各种事物进行抽象，把它封装成一种数据类型——类。<br>无论壁灯、吊灯、吸顶灯，他们都是灯，拥有各自的特点，我们可以将这些共同的东西进行抽象，封装成Lamp这个类。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装则是将灯的属性和方法都封装到一个结构体里。<strong>封装后的结构体就相当于一个类</strong>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lamp</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> on;</span><br><span class="line">    <span class="type">int</span> brightness;</span><br><span class="line">    <span class="comment">/*  self是一个指向当前结构体实例的指针  */</span></span><br><span class="line">    <span class="type">void</span> (*turn_on)(<span class="keyword">struct</span> Lamp *self);</span><br><span class="line">    <span class="type">void</span> (*turn_off)(<span class="keyword">struct</span> Lamp *self);</span><br><span class="line">&#125; Lamp;</span><br></pre></td></tr></table></figure><p>这样我们就得到了我们的Lamp类啦，但是子类想要使用该类的属性和方法该如何继承呢？</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>我们封装一个类的目的就是为了继承，从而实现代码的复用。<br>继承的实现：将基类放在结构体开头来模拟继承。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* &quot;子类&quot;：FlashingLamp */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Lamp base;</span><br><span class="line">    <span class="type">int</span> freq_ms;</span><br><span class="line">&#125; FlashingLamp;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lamp_turn_on</span><span class="params">(Lamp *self)</span>   &#123; self-&gt;on = <span class="number">1</span>; <span class="built_in">puts</span>(<span class="string">&quot;Lamp: on&quot;</span>); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lamp_turn_off</span><span class="params">(Lamp *self)</span> &#123; self-&gt;on = <span class="number">0</span>; <span class="built_in">puts</span>(<span class="string">&quot;Lamp: off&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">Lamp *<span class="title function_">Lamp_new</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    Lamp *l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lamp));</span><br><span class="line">    l-&gt;on = <span class="number">0</span>;</span><br><span class="line">    l-&gt;turn_on = lamp_turn_on;</span><br><span class="line">    l-&gt;turn_off = lamp_turn_off;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如代码所示，我们在结构体类型FlashingLamp里面内嵌了结构体类型Lamp，此时FlashingLamp就相当于模拟了一个子类，而Lamp相当于父类。通过这种内嵌就实现了子类<strong>继承</strong>了父类的属性和方法。<br>子类不仅可以直接复用父类中定义的属性和方法，还可以在父类的基础上拓展自己的属性和方法。<br>对于不同的灯我们打开的方式也不一样，所以我们可以在继承的过程中<strong>重新定义父类</strong>。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">flashing_turn_on</span><span class="params">(Lamp *self)</span> &#123;</span><br><span class="line">    <span class="comment">/* 子类覆盖行为 */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;FlashingLamp: start flashing&quot;</span>);</span><br><span class="line">    self-&gt;on = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FlashingLamp *<span class="title function_">FlashingLamp_new</span><span class="params">(<span class="type">int</span> freq_ms)</span> &#123;</span><br><span class="line">    FlashingLamp *f = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(FlashingLamp));</span><br><span class="line">    f-&gt;base.on = <span class="number">0</span>;</span><br><span class="line">    f-&gt;base.turn_on = flashing_turn_on; <span class="comment">/* 覆盖方法 */</span></span><br><span class="line">    f-&gt;base.turn_off = lamp_turn_off;</span><br><span class="line">    f-&gt;freq_ms = freq_ms;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  Lamp *a = Lamp_new();</span><br><span class="line">  <span class="comment">/*  强制转换成基类指针  */</span></span><br><span class="line">  Lamp *b = (Lamp*)FlashingLamp_new(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">  a-&gt;turn_on(a);</span><br><span class="line">  b-&gt;turn_on(b);</span><br><span class="line"></span><br><span class="line">  a-&gt;turn_off(a);</span><br><span class="line">  b-&gt;turn_off(b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如上所示，我们通过基类指针去调用子类中的不同实现，就叫作多态。</p>]]></content>
      
      
      <categories>
          
          <category> C语言进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LVGL的移植指南</title>
      <link href="/_posts/64580/"/>
      <url>/_posts/64580/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> LVGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LVGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreerRTOS的中断机制</title>
      <link href="/_posts/6/"/>
      <url>/_posts/6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> FreeRTOS内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreerRTOS的任务管理</title>
      <link href="/_posts/5/"/>
      <url>/_posts/5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> FreeRTOS内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreerRTOS的调度器</title>
      <link href="/_posts/7/"/>
      <url>/_posts/7/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> FreeRTOS内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreerRTOS的内存管理</title>
      <link href="/_posts/8/"/>
      <url>/_posts/8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> FreeRTOS内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
