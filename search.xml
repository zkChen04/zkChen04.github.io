<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/_posts/3/"/>
      <url>/_posts/3/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-屏驱ST7789V-SPI开发description-tags-MCU驱动开发categories-MCU驱动开发top-img-transparentcopyright-falseabbrlink-31488date-2025-10-03-00-00-00"><a href="#title-屏驱ST7789V-SPI开发description-tags-MCU驱动开发categories-MCU驱动开发top-img-transparentcopyright-falseabbrlink-31488date-2025-10-03-00-00-00" class="headerlink" title="title: 屏驱ST7789V_SPI开发description:tags:  - MCU驱动开发categories: MCU驱动开发top_img: transparentcopyright: falseabbrlink: 31488date: 2025-10-03 00:00:00"></a>title: 屏驱ST7789V_SPI开发<br>description:<br>tags:<br>  - MCU驱动开发<br>categories: MCU驱动开发<br>top_img: transparent<br>copyright: false<br>abbrlink: 31488<br>date: 2025-10-03 00:00:00</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/23/"/>
      <url>/_posts/23/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/22/"/>
      <url>/_posts/22/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/21/"/>
      <url>/_posts/21/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/1/"/>
      <url>/_posts/1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/20/"/>
      <url>/_posts/20/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/19/"/>
      <url>/_posts/19/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/18/"/>
      <url>/_posts/18/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/16/"/>
      <url>/_posts/16/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/14/"/>
      <url>/_posts/14/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/13/"/>
      <url>/_posts/13/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/28/"/>
      <url>/_posts/28/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/24/"/>
      <url>/_posts/24/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/29/"/>
      <url>/_posts/29/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/25/"/>
      <url>/_posts/25/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/27/"/>
      <url>/_posts/27/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/15/"/>
      <url>/_posts/15/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/10/"/>
      <url>/_posts/10/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/26/"/>
      <url>/_posts/26/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/9/"/>
      <url>/_posts/9/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/8/"/>
      <url>/_posts/8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/7/"/>
      <url>/_posts/7/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/6/"/>
      <url>/_posts/6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/5/"/>
      <url>/_posts/5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/4/"/>
      <url>/_posts/4/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/2/"/>
      <url>/_posts/2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/1/"/>
      <url>/_posts/1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/12/"/>
      <url>/_posts/12/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/11/"/>
      <url>/_posts/11/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/4/"/>
      <url>/_posts/4/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/1/"/>
      <url>/_posts/1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/3/"/>
      <url>/_posts/3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/2/"/>
      <url>/_posts/2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/_posts/9/"/>
      <url>/_posts/9/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FreerRTOS的内存管理</title>
      <link href="/_posts/8/"/>
      <url>/_posts/8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> FreeRTOS内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreerRTOS的中断机制</title>
      <link href="/_posts/6/"/>
      <url>/_posts/6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> FreeRTOS内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreerRTOS的调度器</title>
      <link href="/_posts/7/"/>
      <url>/_posts/7/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> FreeRTOS内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreerRTOS的任务管理</title>
      <link href="/_posts/5/"/>
      <url>/_posts/5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> FreeRTOS内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS内核开发</title>
      <link href="/_posts/17/"/>
      <url>/_posts/17/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> FreeRTOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RTOS内核分析-前置知识</title>
      <link href="/_posts/37837/"/>
      <url>/_posts/37837/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> ARM架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM架构 </tag>
            
            <tag> FreeRTOS </tag>
            
            <tag> RTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LVGL的移植指南</title>
      <link href="/_posts/64580/"/>
      <url>/_posts/64580/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> LVGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LVGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浦洋P169触摸屏驱动开发</title>
      <link href="/_posts/31489/"/>
      <url>/_posts/31489/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> MCU驱动开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCU驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>屏驱ST7789V_SPI开发</title>
      <link href="/_posts/31488/"/>
      <url>/_posts/31488/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> MCU驱动开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCU驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时钟树</title>
      <link href="/_posts/36808/"/>
      <url>/_posts/36808/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要从STM32F1平台出发，介绍时钟树的概念，结合时钟树的框图，详细讲解时钟树的基本原理和配置过程。</p></blockquote><h1 id="你可能会有的疑惑？"><a href="#你可能会有的疑惑？" class="headerlink" title="你可能会有的疑惑？"></a>你可能会有的疑惑？</h1><p>MCU的时钟树是跟着ARM的Cortex-M4架构走，还是跟着ST的F4系列走？<br>简单说，每款MCU的时钟树，都是芯片厂商为其“量身定制”的。ARM架构只是定义了内核需要哪些时钟信号以及如何与它们接口。而具体的时钟树配置，是由芯片厂商（ST）根据其具体的硬件资源和性能需求，进行定制的。</p><h1 id="什么是时钟树？"><a href="#什么是时钟树？" class="headerlink" title="什么是时钟树？"></a>什么是时钟树？</h1><p>MCU内部有许多外设，这些外设需要不同的时钟信号来工作。而我们的晶振只能产生单一频率的主时钟信号，<br>为了满足这些外设的不同时钟需求，我们需要对这个主时钟信号进行分频、倍频或相位调整，生成不同频率的时钟信号，供给不同的外设使用。最终各个时钟线呈现出来的结构就像一棵树一样，所以被称为时钟树。</p><h1 id="时钟源"><a href="#时钟源" class="headerlink" title="时钟源"></a>时钟源</h1><p><img src="/../../img/MCU%E7%90%86%E8%A7%A3/F4%E6%97%B6%E9%92%9F%E6%A0%91.png" alt="STM32F407时钟树"></p><blockquote><p>从图片可以看出来，STM32F4中有5个最重要的时钟源，为HSI、HSE、LSI、LSE、PLL。<br>其中PLL实际是分为两个时钟源，分别为主PLL和专用PLL。讲解顺序是按图中蓝圈标示的顺序。<br>命名规则为：L代表Low，H代表High，S代表Speed,I代表Internal,E代表External。</p></blockquote><h2 id="LSI内部低速时钟"><a href="#LSI内部低速时钟" class="headerlink" title="LSI内部低速时钟"></a>LSI内部低速时钟</h2><p>RC振荡器，频率为32kHz左右。供独立看门狗和自动唤醒单元使用。</p><h2 id="LSE外部低速时钟"><a href="#LSE外部低速时钟" class="headerlink" title="LSE外部低速时钟"></a>LSE外部低速时钟</h2><p>接频率为32.768kHz的石英晶体，这个主要是RTC的时钟源。</p><h2 id="HSE外部高速时钟"><a href="#HSE外部高速时钟" class="headerlink" title="HSE外部高速时钟"></a>HSE外部高速时钟</h2><p>可接石英&#x2F;陶瓷谐振器，或者接外部时钟源，频率范围为4MHz~26MHz。HSE可以直接作为系统时钟或者PLL的输入。</p><h2 id="HSI内部高速时钟"><a href="#HSI内部高速时钟" class="headerlink" title="HSI内部高速时钟"></a>HSI内部高速时钟</h2><p>RC振荡器，频率为16MHz。可以直接作为系统时钟或者用作PLL输入。</p><h2 id="PLL锁相环倍频输出"><a href="#PLL锁相环倍频输出" class="headerlink" title="PLL锁相环倍频输出"></a>PLL锁相环倍频输出</h2><p>STM32F4有两个PLL：</p><ol><li>主PLL(PLL)由HSE或者HSI提供时钟信号，并具有两个不同的输出时钟。</li></ol><ul><li>第一个输出PLLP用于生成高速的系统时钟(最高168MHz)。</li><li>第二个输出PLLQ用于生成USB OTG FS的时钟(48MHz)，随机数发生器的时钟和SDIO时钟。</li><li>专用PLL(PLLI2S)用于生成精确时钟，从而在I2S接口实现高品质音频性能。<br><strong>这里我们着重看看主PLL时钟第一个高速时钟输出PLLP的计算方法</strong>。</li></ul><ol><li><strong>大概分析</strong>：主PLL的输入先经过一个分频系数为M的分频器成为了VCO的时钟输入，<br>（VCO是PLL的一部分，压控振荡器），然后再经过倍频系数为N的倍频器，<br>最后再经过一个分频系数为P（系统时钟的）或者Q（外设时钟）的分频器之后才生成主PLL时钟。</li><li><strong>举例分析</strong>：<br>(1)假设HSE &#x3D; 8MHZ,我们选择了HSE作为PLL的时钟源，因为VCO的时钟必须要在1-2M之间，所以我们设置PLL_M &#x3D; 8M,得到PLL_VCO &#x3D; 1M.<br>(2)接着VCO输入时钟经过VCO倍频因子N倍频之后，成为了VCO的时钟输出，VCO时钟必须在192-432M之间，我们配置N &#x3D; 336，则VCO时钟输出为336M，VCO时钟输出后有3个分频因子。</li></ol><ul><li>PLLCLK 分频因子 P </li><li>时钟分频因子 Q</li><li>分频因子 R（F446 才有，F407 没有）。</li></ul><ol start="3"><li>有关 PLL 的配置有一个专门的 RCC PLL 配置寄存器<strong>RCC_PLLCFGR</strong>，具体描述看手册即可。</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VCOCLK_IN = PLLCLK_IN / M = HSE / <span class="number">8</span> = <span class="number">1</span>M</span><br><span class="line">VCOCLK_OUT = VCOCLK_IN * N = <span class="number">1</span>M * <span class="number">336</span> = <span class="number">336</span>M </span><br><span class="line">PLLCLK_OUT=VCOCLK_OUT/P=<span class="number">336</span>/<span class="number">2</span>=<span class="number">168</span>M  </span><br></pre></td></tr></table></figure><h2 id="上面提到的系统时钟"><a href="#上面提到的系统时钟" class="headerlink" title="上面提到的系统时钟"></a>上面提到的系统时钟</h2><p>系统时钟是MCU的主要时钟源，它提供给所有的外设。系统时钟来源可以是：HSI、PLLCLK、HSE，具体的由时钟配置寄存器<strong>RCC_CFGR</strong> 的<strong>SW位</strong>配置。<br>我们这里设置系统时钟：SYSCLK &#x3D; PLLCLK &#x3D; 168M。如果系统时钟是由 HSE 经过 PLL 倍频之后的 PLLCLK 得到，当 HSE 出现故障的时候，系统时钟会切换为 HSI&#x3D;16M，直到 HSE 恢复正常为止。</p><h2 id="AHB总线时钟HCLK"><a href="#AHB总线时钟HCLK" class="headerlink" title="AHB总线时钟HCLK"></a>AHB总线时钟HCLK</h2><p>系统时钟 SYSCLK 经过 AHB 预分频器分频之后得到时钟叫 AHB 总线时钟，即 HCLK。<br>分频因子可以是:[1,2,4,8,16,64,128,256,512]，具体的由时钟配置寄存器 <strong>RCC_CFGR</strong>的<strong>HPRE位</strong>设置。<br>片上大部分外设的时钟都是经过 HCLK 分频得到，至于 AHB 总线上的外设的时钟设置为多少，得等到我们使用该外设的时候才设置，我们这里只需设置好 APB 的时钟即可。我们这里设置为 1 分频，即 HCLK&#x3D;SYSCLK&#x3D;168M。</p><h2 id="APB2总线时钟PCLK2"><a href="#APB2总线时钟PCLK2" class="headerlink" title="APB2总线时钟PCLK2"></a>APB2总线时钟PCLK2</h2><p>APB2 总线时钟 PCLK2 由 HCLK 经过高速 APB2 预分频器得到。<br>分频因子可以 是:[1,2,4,8,16]，具体由时钟配置寄存器<strong>RCC_CFGR</strong>的<strong>PPRE2位</strong>设置。<br>HCLK2 属于高速的总线时钟，片上高速的外设就挂载到这条总线上，比如全部的 GPIO、USART1、SPI1 等。<br>至于 APB2 总线上的外设的时钟设置为多少，得等到我们使用该外设的时候才设置。<br>我们这里只需设置好 APB2 的时钟即可。我们这里设置为2分频，即PCLK2 &#x3D; HCLK &#x2F;2&#x3D; 84M。</p><h2 id="APB总线时钟PCLK1"><a href="#APB总线时钟PCLK1" class="headerlink" title="APB总线时钟PCLK1"></a>APB总线时钟PCLK1</h2><p>APB1 总线时钟 PCLK1 由 HCLK 经过低速 APB 预分频器得到，分频因子可以是:[1,2,4,8,16]<br>具体由时钟配置寄存器<strong>RCC_CFGR</strong>的<strong>PPRE1位</strong>设置。<br>HCLK1 属于低速的总线时钟，最高为 42M，片上低速的外设就挂载到这条总线上。<br>比如 USART2&#x2F;3&#x2F;4&#x2F;5、SPI2&#x2F;3，I2C1&#x2F;2 等。<br>至于 APB1 总线上的外设的时钟设置为多少，得等到我们使用该外设的时候才设置。<br>我们这里只需设置好 APB1 的时钟即可。我们这里设置为4分频，即PCLK1 &#x3D; HCLK&#x2F;4 &#x3D; 42M。</p><h2 id="APBx定时器时钟"><a href="#APBx定时器时钟" class="headerlink" title="APBx定时器时钟"></a>APBx定时器时钟</h2><p><strong>这个配置定时器的时候，需要特别注意</strong><br>当APBx分频数为1的时候，对应定时器的时钟为APBx的时钟，否则对应定时器时钟都是APB总线的两倍。</p><h1 id="SystemInit函数"><a href="#SystemInit函数" class="headerlink" title="SystemInit函数"></a>SystemInit函数</h1><p>在启动文件中，有一个名为 SystemInit 的函数，它是在单片机启动时被调用的。<br>这个函数的主要作用是初始化系统时钟，设置系统时钟源、分频器和倍频器。<br>在 SystemInit 函数中，我们可以个性化地配置系统时钟为我们需要的频率。</p>]]></content>
      
      
      <categories>
          
          <category> MCU理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时钟树 </tag>
            
            <tag> MCU理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过点灯学习C的面向对象编程思想</title>
      <link href="/_posts/64580/"/>
      <url>/_posts/64580/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象思想是什么？"><a href="#面向对象思想是什么？" class="headerlink" title="面向对象思想是什么？"></a>面向对象思想是什么？</h1><p>有的人说C语言是一门面向过程的编程语言，但是面向过程只是一种设计思想，而不是某种语言的私有财产。那什么是<strong>面向过程</strong>思想，什么是<strong>面向对象</strong>思想？<br><strong>面向过程</strong>专注于“先A，再B，然后C”的流程，适合解决线性的任务。<br><strong>面向对象</strong>专注于“谁？什么状态？能干什么？”，适合复杂系统，例如linux内核。</p><h1 id="为什么我们要学习面向对象思想？"><a href="#为什么我们要学习面向对象思想？" class="headerlink" title="为什么我们要学习面向对象思想？"></a>为什么我们要学习面向对象思想？</h1><p>你有没有过这种体验？读别人写的C语言项目，跟着一个函数跳来跳去，数据传来传去，改一个结构要动十个文件… 感觉自己不是在读代码，而是在走迷宫；<strong>或者</strong>当你自己写一个稍大的程序时，变量越加越多，函数越改越乱，到最后连自己都理不清。这通常不是C语言的错，而是我们被“一步一步来”的面向过程思维框住了。<br><strong>面向对象思想</strong>可以帮助我们把复杂系统拆分成职责清晰的模块，减少函数跳转和全局状态的传播，使代码更易读、可维护并且便于扩展。<br>下面本文将从介绍C语言如何运用<strong>结构体、函数指针</strong>实现面向对象编程的核心理念——<strong>抽象、封装、继承与多态</strong>。</p><h1 id="面向对象的四大基本特性"><a href="#面向对象的四大基本特性" class="headerlink" title="面向对象的四大基本特性"></a>面向对象的四大基本特性</h1><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>我们可以对现实存在的各种事物进行抽象，把它封装成一种数据类型——类。<br>无论壁灯、吊灯、吸顶灯，他们都是灯，拥有各自的特点，我们可以将这些共同的东西进行抽象，封装成Lamp这个类。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装则是将灯的属性和方法都封装到一个结构体里。<strong>封装后的结构体就相当于一个类</strong>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lamp</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> on;</span><br><span class="line">    <span class="type">int</span> brightness;</span><br><span class="line">    <span class="comment">/*  self是一个指向当前结构体实例的指针  */</span></span><br><span class="line">    <span class="type">void</span> (*turn_on)(<span class="keyword">struct</span> Lamp *self);</span><br><span class="line">    <span class="type">void</span> (*turn_off)(<span class="keyword">struct</span> Lamp *self);</span><br><span class="line">&#125; Lamp;</span><br></pre></td></tr></table></figure><p>这样我们就得到了我们的Lamp类啦，但是子类想要使用该类的属性和方法该如何继承呢？</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>我们封装一个类的目的就是为了继承，从而实现代码的复用。<br>继承的实现：将基类放在结构体开头来模拟继承。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* &quot;子类&quot;：FlashingLamp */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Lamp base;</span><br><span class="line">    <span class="type">int</span> freq_ms;</span><br><span class="line">&#125; FlashingLamp;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lamp_turn_on</span><span class="params">(Lamp *self)</span>   &#123; self-&gt;on = <span class="number">1</span>; <span class="built_in">puts</span>(<span class="string">&quot;Lamp: on&quot;</span>); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lamp_turn_off</span><span class="params">(Lamp *self)</span> &#123; self-&gt;on = <span class="number">0</span>; <span class="built_in">puts</span>(<span class="string">&quot;Lamp: off&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">Lamp *<span class="title function_">Lamp_new</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    Lamp *l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lamp));</span><br><span class="line">    l-&gt;on = <span class="number">0</span>;</span><br><span class="line">    l-&gt;turn_on = lamp_turn_on;</span><br><span class="line">    l-&gt;turn_off = lamp_turn_off;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如代码所示，我们在结构体类型FlashingLamp里面内嵌了结构体类型Lamp，此时FlashingLamp就相当于模拟了一个子类，而Lamp相当于父类。通过这种内嵌就实现了子类<strong>继承</strong>了父类的属性和方法。<br>子类不仅可以直接复用父类中定义的属性和方法，还可以在父类的基础上拓展自己的属性和方法。<br>对于不同的灯我们打开的方式也不一样，所以我们可以在继承的过程中<strong>重新定义父类</strong>。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">flashing_turn_on</span><span class="params">(Lamp *self)</span> &#123;</span><br><span class="line">    <span class="comment">/* 子类覆盖行为 */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;FlashingLamp: start flashing&quot;</span>);</span><br><span class="line">    self-&gt;on = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FlashingLamp *<span class="title function_">FlashingLamp_new</span><span class="params">(<span class="type">int</span> freq_ms)</span> &#123;</span><br><span class="line">    FlashingLamp *f = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(FlashingLamp));</span><br><span class="line">    f-&gt;base.on = <span class="number">0</span>;</span><br><span class="line">    f-&gt;base.turn_on = flashing_turn_on; <span class="comment">/* 覆盖方法 */</span></span><br><span class="line">    f-&gt;base.turn_off = lamp_turn_off;</span><br><span class="line">    f-&gt;freq_ms = freq_ms;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  Lamp *a = Lamp_new();</span><br><span class="line">  <span class="comment">/*  强制转换成基类指针  */</span></span><br><span class="line">  Lamp *b = (Lamp*)FlashingLamp_new(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">  a-&gt;turn_on(a);</span><br><span class="line">  b-&gt;turn_on(b);</span><br><span class="line"></span><br><span class="line">  a-&gt;turn_off(a);</span><br><span class="line">  b-&gt;turn_off(b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如上所示，我们通过基类指针去调用子类中的不同实现，就叫作多态。</p>]]></content>
      
      
      <categories>
          
          <category> C语言进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几条简单的ARM汇编指令</title>
      <link href="/_posts/26318/"/>
      <url>/_posts/26318/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是程序"><a href="#什么是程序" class="headerlink" title="什么是程序"></a>什么是程序</h1><p>我认为程序就是</p><ul><li>一段被烧写在flash里面的机器码（指令）（bin文件）</li><li>运行过程中的数据（属于程序里的一部分）</li></ul><p>cpu运行期间会在flash取指令然后执行各种操作。</p><h1 id="程序运行时CPU如何读写内存"><a href="#程序运行时CPU如何读写内存" class="headerlink" title="程序运行时CPU如何读写内存"></a>程序运行时CPU如何读写内存</h1><p>cpu内部有寄存器，R0~R15寄存器<br>读数据是将数据从内存RAM读取到寄存器，写数据是将数据从寄存器写入内存RAM。<br>其中读写操作涉及几条汇编指令：LDR、STR、SUB、ADD、CMP、B、BL、POP、PUSH、LDIMA。<br>下面我们就来介绍一下这些指令。</p><h1 id="ARM汇编简介"><a href="#ARM汇编简介" class="headerlink" title="ARM汇编简介"></a>ARM汇编简介</h1><p>了解汇编指令之前我们了解一下什么是汇编语言：</p><blockquote><p>1985年，ARM公司推出了第一款ARM（Acorn RISC Machine）处理器，采用精简指令集（RISC）设计理念。他们发布了两类指令集：ARM指令集和Thumb指令集。ARM指令集是32位指令，Thumb指令集是16位指令。所以基于ARM架构的CPU可以同时运行ARM指令集和Thumb指令集。<br>那怎么区分当前指令是ARM指令集还是Thumb指令集呢？在程序状态寄存器（CPSR）中，有一个标志位T。当T位为0时，当前指令是ARM指令集；当T位为1时，当前指令是Thumb指令集。<br>但是指令集只是一串二进制代码，我们怎么区分？所以ARM公司推出了Unified Assembly Language（UAL）即统一汇编语言。所以我们只用记住一些简单的指令，在程序前声明THUMB&#x2F;ARM指令集之后就可以编写代码了。</p></blockquote><h2 id="LDR读内存"><a href="#LDR读内存" class="headerlink" title="LDR读内存"></a>LDR读内存</h2><blockquote><p>格式为：LDR 目的寄存器,&lt;内存地址&gt;</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LDR  R0,[R1]       ;将内存地址为R1的字数据读入寄存器R0。</span><br><span class="line">LDR  R0,[R1,R2]    ;将内存地址为R1+R2的字数据读入寄存器R0。</span><br><span class="line">LDR  R0,[R1,＃<span class="number">8</span>]   ;将内存地址为R1+<span class="number">8</span>的字数据读入寄存器R0。</span><br><span class="line">LDR  R0,[R1,R2]!   ;将内存地址为R1+R2的字数据读入寄存器R0，并将新地址R1＋R2写入R1。</span><br><span class="line">LDR  R0,[R1,＃<span class="number">8</span>]!  ;将内存地址为R1+<span class="number">8</span>的字数据读入寄存器R0，并将新地址R1＋<span class="number">8</span>写入R1。</span><br><span class="line">LDR  R0,[R1],R2    ;将内存地址为R1的字数据读入寄存器R0，并将新地址R1＋R2写入R1。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="立即数"><a href="#立即数" class="headerlink" title="立即数"></a>立即数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MOV R0, #VAL  <span class="comment">//  将立即数VAL加载到寄存器R0中</span></span><br></pre></td></tr></table></figure><p><strong>什么是立即数，val可以是任何数吗？</strong></p><ul><li>立即数是指在指令中直接给出的数值。ARM汇编中用#前缀表示立即数。</li><li>立即数并不是任意 32 位整数，由于 ARM 指令的固定长度（32 位），其中一部分位必须用于表示操作码、目标寄存器等。例如“MOV R0, #VAL”这条指令本身就是16位或者32位指令，哪来的空间保存任意数值的VAL?我们暂且认为立即数满足某种规定。</li></ul><h3 id="LDR伪指令"><a href="#LDR伪指令" class="headerlink" title="LDR伪指令"></a>LDR伪指令</h3><p><strong>但是我就是想将任意数加载到寄存器中，怎么办？</strong><br>这就引出了<strong>LDR伪指令：LDR R0, &#x3D;VAL</strong>。<br>什么是伪指令？伪指令指的就是不存在的指令，只是编译器在编译时将其转换为实际的指令。例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LDR R0, =<span class="number">0X12</span>  </span><br><span class="line"><span class="comment">//  0X12是一个立即数，那么编译器会将其转换为MOV R0, #0X12</span></span><br><span class="line">     </span><br><span class="line">LDR R0, =<span class="number">0X12345678</span> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  0X12345678不是一个立即数</span></span><br><span class="line"><span class="comment">  编译器会将其转换为LDR R0, [PC, #offset]</span></span><br><span class="line"><span class="comment">  其中这个offset在链接的时候会被计算出来</span></span><br><span class="line"><span class="comment">  label DCD 0X12345678  // 在程序的某一个位置存放这个数据</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="写内存STR"><a href="#写内存STR" class="headerlink" title="写内存STR"></a>写内存STR</h2><blockquote><p>格式为：STR 源寄存器,&lt;内存地址&gt;</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STR R0,[R1],＃<span class="number">8</span> ;将R0中的字数据写入以R1为地址的存储器中，并将新地址R1＋<span class="number">8</span>写入R1。</span><br><span class="line">STR R0,[R1,＃<span class="number">8</span>] ;将R0中的字数据写入以R1＋<span class="number">8</span>为地址的存储器中。</span><br><span class="line">STR R1,[R0]     ;将R1寄存器的值，传送到以r0为地址的存储器中。</span><br></pre></td></tr></table></figure><h2 id="加减SUB、ADD"><a href="#加减SUB、ADD" class="headerlink" title="加减SUB、ADD"></a>加减SUB、ADD</h2><p>ADD{S} 目的寄存器,操作数1,操作数2：把两个操作数相加，并将结果存放到目的寄存器中。<br>操作数1应是一个寄存器，操作数2可以是一个寄存器、被移位的寄存器，或者一个立即数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADD  R0,R1,R2           ; R0 = R1 + R2</span><br><span class="line">ADD  R0,R1,#<span class="number">256</span>         ; R0 = R1 + <span class="number">256</span></span><br><span class="line">ADD  R0,R2,R3,LSL#<span class="number">1</span>     ; R0 = R2 + (R3 &lt;&lt; <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">SUB  R0,R1,R2         ;R0 = R1 - R2</span><br><span class="line">SUB  R0,R1,#<span class="number">256</span>       ;R0 = R1 - <span class="number">256</span></span><br><span class="line">SUB  R0,R2,R3,LSL#<span class="number">1</span>   ;R0 = R2 - (R3 &lt;&lt; <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="比较CMP"><a href="#比较CMP" class="headerlink" title="比较CMP"></a>比较CMP</h2><p>CMP{条件} 操作数1,操作数2：将一个寄存器的内容和另一个寄存器的内容或立即数进行比较，比较结果放在CPSR中条件标志位的值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CMP R1,R0     ;将寄存器R1的值与寄存器R0的值相减，并根据结果设置CPSR的标志位</span><br><span class="line">CMP R1,＃<span class="number">100</span>  ;将寄存器R1的值与立即数<span class="number">100</span>相减，并根据结果设置CPSR的标志位</span><br></pre></td></tr></table></figure><h2 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h2><table><thead><tr><th align="left">指令</th><th align="left">功能描述</th><th align="left">应用场景</th><th align="left">对寄存器的影响</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">B</td><td align="left">实现无条件跳转，跳转值为相对当前PC的偏移量（24位有符号数扩展为32位）</td><td align="left">短距离跳转、循环或条件跳转</td><td align="left">仅改变程序计数器（PC）</td><td align="left"><code>B Label;</code><br><code>CMP R1, #0;</code><br><code>BEQ Label;</code></td></tr><tr><td align="left">BL</td><td align="left">跳转前将下一条指令地址存入链接寄存器LR（R14），便于子程序返回</td><td align="left">子程序调用</td><td align="left">改变PC，将返回地址存入LR</td><td align="left"><code>BL func</code></td></tr><tr><td align="left">BX</td><td align="left">跳转到指定地址，根据目标地址寄存器最低位&#x2F;两位切换处理器状态（1为Thumb，0为ARM）</td><td align="left">ARM与Thumb指令集间切换跳转</td><td align="left">改变PC，切换处理器状态</td><td align="left"><code>BX R0</code></td></tr><tr><td align="left">BLX</td><td align="left">结合BL和BX功能，跳转前存返回地址到LR，并切换处理器状态</td><td align="left">调用Thumb指令集子程序（调用者为ARM指令集）</td><td align="left">改变PC，将返回地址存入LR，切换处理器状态</td><td align="left"><code>BLX R0</code></td></tr></tbody></table><blockquote><p>不了解栈的建议先看这篇博客：<a href="http://localhost:4000/_posts/52059/">内存堆栈管理</a></p></blockquote><h2 id="POP出栈"><a href="#POP出栈" class="headerlink" title="POP出栈"></a>POP出栈</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">内存：</span><br><span class="line"><span class="number">0x2000</span> <span class="number">0294</span> = <span class="number">0x1212</span> <span class="number">1212</span></span><br><span class="line"><span class="number">0x2000</span> <span class="number">0298</span> = <span class="number">0xEFEF</span> EFEF</span><br><span class="line"><span class="number">0x2000</span> <span class="number">029</span>C = <span class="number">0x0000</span> <span class="number">2079</span></span><br><span class="line"><span class="number">0x2000</span> <span class="number">02</span>A0 = <span class="number">0x0100</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line">一开始SP指向<span class="number">0x2000</span> <span class="number">0294</span>这个地址</span><br><span class="line">执行指令：POP &#123;R0 -R3&#125; 之后</span><br><span class="line"></span><br><span class="line">R0 = <span class="number">0x1212</span> <span class="number">1212</span></span><br><span class="line">R1 = <span class="number">0xEFEF</span> EFEF</span><br><span class="line">R2 = <span class="number">0x0000</span> <span class="number">2079</span></span><br><span class="line">R3 = <span class="number">0x0100</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line">SP指向的位置为: <span class="number">0x2000</span> <span class="number">02</span>A4</span><br></pre></td></tr></table></figure><p>从上面例子可以看出两点</p><ul><li>POP指令会将栈顶的数据弹出，并且SP会指向栈顶的下一个地址</li><li>{R0-R3} 这些高标号的寄存器对应高地址</li><li>出栈的时候SP指针从低地址向高地址移动</li></ul><h2 id="PUSH压栈"><a href="#PUSH压栈" class="headerlink" title="PUSH压栈"></a>PUSH压栈</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">一开始SP指向 <span class="number">0x2000</span> <span class="number">0284</span></span><br><span class="line"></span><br><span class="line">这个时候寄存器的值：</span><br><span class="line">R0 = <span class="number">0x1212</span> <span class="number">1212</span></span><br><span class="line">R1 = <span class="number">0x0000</span> <span class="number">1B</span>C3</span><br><span class="line">R2 = <span class="number">0x0000</span> <span class="number">1B</span>C3</span><br><span class="line">R3 = <span class="number">0x0000</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line">执行指令 PUSH &#123;R0 - R3&#125; 之后，</span><br><span class="line"></span><br><span class="line">内存地址：</span><br><span class="line"><span class="number">0x2000</span> <span class="number">0274</span>的值为: <span class="number">0x1212</span> <span class="number">1212</span> --------- R0</span><br><span class="line"><span class="number">0x2000</span> <span class="number">0278</span>的值为: <span class="number">0x0000</span> <span class="number">1B</span>C3 --------- R1</span><br><span class="line"><span class="number">0x2000</span> <span class="number">027</span>C的值为: <span class="number">0x0000</span> <span class="number">1B</span>C3 --------- R2</span><br><span class="line"><span class="number">0x2000</span> <span class="number">0280</span>的值为: <span class="number">0x0000</span> <span class="number">0000</span> --------- R3</span><br><span class="line"></span><br><span class="line">执行之后 堆栈指针，指向的地址为: <span class="number">0x2000</span> <span class="number">0274</span></span><br></pre></td></tr></table></figure><p>从上面例子可以看出两点</p><ul><li>PUSH指令会将寄存器中的数据压栈，并且SP会指向栈顶的下一个地址</li><li>{R0-R3} 这些高标号的寄存器对应高地址</li><li>入栈的时候SP指针从高地址向低地址移动</li></ul>]]></content>
      
      
      <categories>
          
          <category> ARM架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM架构 </tag>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机的启动流程</title>
      <link href="/_posts/30383/"/>
      <url>/_posts/30383/</url>
      
        <content type="html"><![CDATA[<h1 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h1><ol><li><p><strong>上电或复位</strong>: 芯片通电或RESET引脚被拉低。</p></li><li><p><strong>读取BOOT引脚</strong>: 硬件逻辑在复位信号的上升沿锁存 BOOT0 和 BOOT1 引脚的电平状态。</p></li><li><p><strong>执行内存重映射</strong>（M3&#x2F;M4才重映射，M7没有重映射）：</p><ul><li>如果 BOOT0&#x3D;0，内部总线矩阵将主闪存（0x08000000）的地址重映射到 0x00000000。</li><li>如果 BOOT0&#x3D;1, BOOT1&#x3D;0，将系统存储器（0x1FFFF000）重映射到 0x00000000。</li><li>如果 BOOT0&#x3D;1, BOOT1&#x3D;1，将SRAM（0x20000000）重映射到 0x00000000。</li></ul></li><li><p><strong>CPU开始执行</strong>：<br>CPU的PC指针指向 0x00000000，开始它的生命周期。它首先从 0x00000000 读取栈顶指针（MSP）的初始值，并加载到SP寄存器。然后从 0x00000004 读取复位处理函数（Reset_Handler）的地址，并加载到PC寄存器。</p><blockquote><p>这段描述适用全部模式：Flash、System Memory、SRAM</p></blockquote></li><li><p><strong>运行软件程序</strong>：</p><ul><li><strong>主闪存模式</strong>：CPU开始执行Reset_Handler，在回调函数中分别执行SystemInit和__main，最后执行main()函数。</li><li><strong>系统存储器模式</strong>：CPU开始执行ST官方的ISP Bootloader中的Reset Handler，在回调函数中做初始化处理后，官方的ISP程序运行，等待通过串口等接收新固件（执行bootloader）。</li><li><strong>SRAM模式</strong>：CPU开始执行0x00000004指向的函数地址下的程序（若用户有将程序拷贝或者是通过写SRAM的方式编写程序，则可正常运行；若SRAM为空，则CPU会触发硬件错误（HardFault）。</li></ul></li></ol><h1 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h1><p>MCU触发了复位事件后，芯片内部的硬件逻辑会检测BOOT0和BOOT1引脚是高电平还是低电平，根据两个BOOT脚的高低电平组合，将不同的物理存储器的起始地址重映射到0x00000000这个地址上。</p><p>紧接着CPU会从0x00000000执行程序，CPU会先将PC指针指向0x00000000，将该地址存放的栈顶指针MSP的初始值取出并加载到CPU寄存器SP中，然后偏移4个字节，将0x00000004地址下存放的复位处理函数Reset_Handler地址取出并加载到CPU寄存器PC中。</p><p>然后CPU就开始执行Reset_Handler函数下的程序，在几种模式下，主要是主闪存模式（即BOOT0为0的模式），CPU开始执行程序Reset_Handler（虚函数），默认为执行<code>system_stm32f10x.c</code>文件下的SystemInit()函数，这个函数主要负责最基本的硬件初始化，如配置系统时钟。</p><p>紧接着执行C库入口函数__main，在该函数下会建立一个符合C语言标准的程序执行环境，包括：分散加载初始化、复制.data段、清零.bss段、C&#x2F;C++库初始化、堆初始化、IO初始化、FPU初始化、调用C++静态构造函数。处理完这些就会调用用户编写的main()函数了。</p><h2 id="main-的具体工作"><a href="#main-的具体工作" class="headerlink" title="__main()的具体工作"></a>__main()的具体工作</h2><table><thead><tr><th align="left">步骤</th><th align="left">任务</th><th align="left">目标</th><th align="left">涉及内存区域</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">分散加载初始化</td><td align="left">建立正确的内存数据映像</td><td align="left">.data, .bss (SRAM)</td></tr><tr><td align="left">1.1</td><td align="left">复制.data段</td><td align="left">将Flash中的初始值赋给SRAM中的全局&#x2F;静态变量</td><td align="left">.data</td></tr><tr><td align="left">1.2</td><td align="left">清零.bss段</td><td align="left">确保未初始化的全局&#x2F;静态变量为0</td><td align="left">.bss</td></tr><tr><td align="left">2</td><td align="left">C&#x2F;C++库初始化</td><td align="left">使标准库函数可用</td><td align="left">Heap, Stack (SRAM)</td></tr><tr><td align="left">2.1</td><td align="left">初始化堆</td><td align="left">为malloc()等动态内存分配做准备</td><td align="left">Heap</td></tr><tr><td align="left">2.2</td><td align="left">初始化I&#x2F;O</td><td align="left">为printf()等函数准备底层接口</td><td align="left">-</td></tr><tr><td align="left">2.3</td><td align="left">初始化FPU</td><td align="left">使能浮点运算单元(如果需要)</td><td align="left">-</td></tr><tr><td align="left">2.4</td><td align="left">调用C++静态构造函数</td><td align="left">正确构造全局C++对象</td><td align="left">-</td></tr><tr><td align="left">3</td><td align="left">调用main()</td><td align="left">将控制权移交给用户代码</td><td align="left">Stack</td></tr><tr><td align="left">4</td><td align="left">处理main()返回</td><td align="left">提供一个确定的程序终止行为</td><td align="left">-</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> ARM架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存堆栈管理</title>
      <link href="/_posts/52059/"/>
      <url>/_posts/52059/</url>
      
        <content type="html"><![CDATA[<h1 id="内存堆栈管理概述"><a href="#内存堆栈管理概述" class="headerlink" title="内存堆栈管理概述"></a>内存堆栈管理概述</h1><p>内存管理是计算机系统中的核心概念，在ARM架构中，内存主要分为栈(Stack)和堆(Heap)两种类型。本文将详细介绍这两种内存类型的管理机制、特点以及在ARM架构下的具体实现。</p><h1 id="栈的管理"><a href="#栈的管理" class="headerlink" title="栈的管理"></a>栈的管理</h1><h2 id="1-1-栈的基本概念"><a href="#1-1-栈的基本概念" class="headerlink" title="1.1 栈的基本概念"></a>1.1 栈的基本概念</h2><p>栈是一种**先进后出(LIFO)**的数据结构，是C语言运行的基础。C语言函数中的局部变量、传递的实参、返回的结果以及编译器生成的临时变量都保存在栈中。</p><h3 id="1-1-1-栈的基本操作"><a href="#1-1-1-栈的基本操作" class="headerlink" title="1.1.1 栈的基本操作"></a>1.1.1 栈的基本操作</h3><p>栈有两种基本操作：</p><ul><li><strong>压栈(push)</strong>: 将数据存入栈中</li><li><strong>弹栈(pop)</strong>: 从栈中取出数据</li></ul><p>ARM架构中使用<code>SP</code>寄存器(Stack Pointer，R13)作为栈指针，用于维护栈的这两种操作。</p><h3 id="1-1-2-栈的分类"><a href="#1-1-2-栈的分类" class="headerlink" title="1.1.2 栈的分类"></a>1.1.2 栈的分类</h3><p>根据栈指针SP指向栈顶元素的不同，栈可分为：</p><ul><li><strong>满栈(Full Stack)</strong>: SP总是指向栈顶元素</li><li><strong>空栈(Empty Stack)</strong>: SP总是指向栈顶元素的下一个可用位置</li></ul><p>根据栈的生长方向不同，栈又分为：</p><ul><li><strong>递增栈(Ascending Stack)</strong>: 栈从低地址向高地址增长</li><li><strong>递减栈(Descending Stack)</strong>: 栈从高地址向低地址增长</li></ul><p>ARM架构中常用的是<strong>满递减栈(Full Descending Stack)</strong>，本文主要叙述这种栈类型。</p><p><img src="/../../img/ARM%E6%9E%B6%E6%9E%84/%E6%BB%A1%E9%80%92%E5%87%8F%E6%A0%88.png"></p><p>如上图所示，满递减栈的栈指针SP总是指向栈顶元素，当有新元素入栈时，栈指针先从高地址向低地址移动，然后把新元素放入SP指向的空间。出栈顺序则刚好相反，先弹出栈顶元素，然后栈指针向高地址移动，指向下一个栈顶元素。</p><h2 id="1-2-栈的初始化"><a href="#1-2-栈的初始化" class="headerlink" title="1.2 栈的初始化"></a>1.2 栈的初始化</h2><p>栈的初始化其实就是栈指针SP的初始化。在系统启动过程中，内存初始化后，将栈指针指向内存中的一段连续空间，就完成了栈的初始化。栈指针指向的这片内存空间被称为<strong>栈空间</strong>。</p><ul><li>栈初始化后，SP指向栈空间的栈顶</li><li>当进行入栈、出栈操作时，SP会随着栈顶的变化上下移动</li><li>在栈的初始化过程中，除了指定栈的起始地址，还需要指定栈空间的大小</li><li>ARM处理器使用R13寄存器(SP)和R11寄存器(FP)来管理堆栈，FP用于指向栈帧的底部</li></ul><h2 id="1-3-函数调用与栈帧"><a href="#1-3-函数调用与栈帧" class="headerlink" title="1.3 函数调用与栈帧"></a>1.3 函数调用与栈帧</h2><h3 id="1-3-1-栈帧的概念"><a href="#1-3-1-栈帧的概念" class="headerlink" title="1.3.1 栈帧的概念"></a>1.3.1 栈帧的概念</h3><p>每一个函数在调用时都会在栈中分配专门的空间，这个空间被称为<strong>栈帧(Frame Pointer, FP)</strong>。每个栈帧都使用两个寄存器来维护：</p><ul><li>FP指向栈帧的底部</li><li>SP指向栈帧的顶部</li></ul><p>函数的栈帧主要用于保存：</p><ul><li>局部变量</li><li>函数实参</li><li>函数调用者的返回地址</li><li>上一级函数栈帧的起始地址(FP)</li><li>函数的上下文信息</li><li>编译器生成的临时变量(可选)</li></ul><h3 id="1-3-2-函数调用链"><a href="#1-3-2-函数调用链" class="headerlink" title="1.3.2 函数调用链"></a>1.3.2 函数调用链</h3><p>一个程序中往往存在多级函数调用，每一级调用都会运行不同的函数，每个函数都有自己的栈帧空间。上一级函数栈帧的起始地址(FP)会保存到当前函数的栈帧中，多个栈帧通过FP构成一个链，这个链就是<strong>函数调用栈</strong>。</p><p>调试器支持的<strong>回溯功能</strong>就是基于这个调用链来分析函数的调用关系的。</p><h2 id="1-4-参数传递机制"><a href="#1-4-参数传递机制" class="headerlink" title="1.4 参数传递机制"></a>1.4 参数传递机制</h2><p>函数调用过程中的参数传递，一般有两种方式：</p><h3 id="1-4-1-基于寄存器的参数传递"><a href="#1-4-1-基于寄存器的参数传递" class="headerlink" title="1.4.1 基于寄存器的参数传递"></a>1.4.1 基于寄存器的参数传递</h3><p>ARM处理器为了提高程序运行效率，会优先使用寄存器来传参。根据**ATPCS(ARM-Thumb Procedure Call Standard)**规则：</p><ul><li>当参数个数小于4时，直接使用R0～R3寄存器传递</li><li>当参数个数大于4时，前4个参数使用寄存器传递，剩余的参数则压入堆栈保存</li></ul><h3 id="1-4-2-基于栈的参数传递"><a href="#1-4-2-基于栈的参数传递" class="headerlink" title="1.4.2 基于栈的参数传递"></a>1.4.2 基于栈的参数传递</h3><p>对于超出寄存器数量限制的参数，或者某些特殊类型的参数，会使用栈来传递。这些参数会被压入调用者的栈帧中，供被调用函数访问。</p><h2 id="1-5-形参和实参"><a href="#1-5-形参和实参" class="headerlink" title="1.5 形参和实参"></a>1.5 形参和实参</h2><h3 id="1-5-1-值传递的本质"><a href="#1-5-1-值传递的本质" class="headerlink" title="1.5.1 值传递的本质"></a>1.5.1 值传递的本质</h3><p>C语言中函数的参数传递是<strong>值传递</strong>，形参保存的是实参的副本。</p><ul><li>形参只有在函数被调用时才会在栈中分配临时的存储单元，用来保存传递过来的实参值</li><li>函数运行结束后，形参单元随着栈帧的销毁而被释放</li></ul><h3 id="1-5-2-形参和实参的关系"><a href="#1-5-2-形参和实参的关系" class="headerlink" title="1.5.2 形参和实参的关系"></a>1.5.2 形参和实参的关系</h3><p>变量作为实参传递时，只是将变量值复制给了形参，形参和实参在栈中位于不同的存储单元。因此：</p><ul><li>在函数运行期间，改变形参的值并不会改变原来实参的值</li><li>函数对形参的任何修改都不会影响到实参变量本身</li></ul><h2 id="1-6-栈与作用域"><a href="#1-6-栈与作用域" class="headerlink" title="1.6 栈与作用域"></a>1.6 栈与作用域</h2><h3 id="1-6-1-全局变量"><a href="#1-6-1-全局变量" class="headerlink" title="1.6.1 全局变量"></a>1.6.1 全局变量</h3><ul><li>定义在函数体外</li><li>作用域范围：从声明处到文件结束</li><li>其他文件可通过<code>extern</code>声明后使用</li><li>生命周期：整个程序运行期间</li></ul><h3 id="1-6-2-局部变量"><a href="#1-6-2-局部变量" class="headerlink" title="1.6.2 局部变量"></a>1.6.2 局部变量</h3><ul><li>定义在函数内</li><li>作用域范围：仅在函数体内使用</li><li>生命周期：仅存在于函数运行期间</li><li>每次函数被调用时，会在栈中重新分配栈帧空间，因此局部变量的地址可能不同</li></ul><h3 id="1-6-3-块级作用域"><a href="#1-6-3-块级作用域" class="headerlink" title="1.6.3 块级作用域"></a>1.6.3 块级作用域</h3><p>编译器在编译程序时，根据一对大括号<code>{}</code>来限定变量的作用域。在大括号内部定义的变量，只能在大括号内部使用。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">100</span>;  <span class="comment">// 内部作用域的变量a，覆盖外部作用域的a</span></span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> b = <span class="number">200</span>;  <span class="comment">// static改变了存储属性，但作用域仍受&#123;&#125;限制</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内部a = %d\n&quot;</span>, a);  <span class="comment">// 输出: 内部a = 100</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);  <span class="comment">// 输出: b = 200</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;外部a = %d\n&quot;</span>, a);  <span class="comment">// 输出: 外部a = 10</span></span><br><span class="line">    <span class="comment">// printf(&quot;b = %d\n&quot;, b);  // 错误：b超出作用域</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>static</code>关键字虽然改变了局部变量的存储属性(从栈空间移到静态存储区)，延长了其生命周期，但作用域仍然由<code>{}</code>决定。</p><h1 id="堆的管理"><a href="#堆的管理" class="headerlink" title="堆的管理"></a>堆的管理</h1><h2 id="2-1-堆与栈的比较"><a href="#2-1-堆与栈的比较" class="headerlink" title="2.1 堆与栈的比较"></a>2.1 堆与栈的比较</h2><p>堆内存与栈内存相比，具有以下特点：</p><table><thead><tr><th>特性</th><th>堆内存</th><th>栈内存</th></tr></thead><tbody><tr><td>分配方式</td><td>动态分配，由程序员手动申请和释放</td><td>自动分配，由编译器管理</td></tr><tr><td>访问方式</td><td>匿名的，通过指针间接访问</td><td>通过变量名或栈指针相对寻址访问</td></tr><tr><td>生命周期</td><td>由程序员控制，函数退出时不会自动释放</td><td>函数运行时分配，函数结束时自动释放</td></tr><tr><td>内存结构</td><td>不连续，容易产生碎片</td><td>连续的内存块</td></tr><tr><td>分配效率</td><td>较低</td><td>较高</td></tr></tbody></table><h2 id="2-2-堆内存的分配与释放"><a href="#2-2-堆内存的分配与释放" class="headerlink" title="2.2 堆内存的分配与释放"></a>2.2 堆内存的分配与释放</h2><p>当用户使用<code>malloc()</code>函数申请一片内存时，需要从堆内存中分配；当使用<code>free()</code>函数释放一片内存时，将这片内存归还到堆内存中。堆内存自身需要专门的管理和维护，以应对用户的内存申请和释放请求。</p><h2 id="2-3-裸机下的堆内存管理"><a href="#2-3-裸机下的堆内存管理" class="headerlink" title="2.3 裸机下的堆内存管理"></a>2.3 裸机下的堆内存管理</h2><p>在裸机开发环境中，如Keil MDK：</p><h3 id="2-3-1-堆的定义"><a href="#2-3-1-堆的定义" class="headerlink" title="2.3.1 堆的定义"></a>2.3.1 堆的定义</h3><p>在启动文件<code>startxx.s</code>中定义了堆的起始地址和大小：<br><img src="/../../img/ARM%E6%9E%B6%E6%9E%84/keil%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86.png" alt="KEIL的堆管理"></p><h3 id="2-3-2-堆管理的实现"><a href="#2-3-2-堆管理的实现" class="headerlink" title="2.3.2 堆管理的实现"></a>2.3.2 堆管理的实现</h3><p>Keil编译器实现了一个简化版的C标准库，称为<strong>MicroLIB</strong>。该库实现了C标准规定的大部分函数功能(如<code>malloc</code>、<code>memcpy</code>等)，并针对嵌入式平台做了优化，使其体积更小，更适合资源有限的嵌入式系统。</p><h3 id="2-3-3-内存碎片化问题"><a href="#2-3-3-内存碎片化问题" class="headerlink" title="2.3.3 内存碎片化问题"></a>2.3.3 内存碎片化问题</h3><p>在裸机环境下，一片连续的堆内存空间经过多次小块内存的申请和释放后，会造成<strong>内存碎片化</strong>，在内存中留下越来越多、越来越小的空闲内存块。此时如果再申请一片连续的大块内存，即使总的空闲内存足够，也可能因为没有连续的空闲块而失败。</p><h3 id="2-3-4-内存碎片化的解决方案"><a href="#2-3-4-内存碎片化的解决方案" class="headerlink" title="2.3.4 内存碎片化的解决方案"></a>2.3.4 内存碎片化的解决方案</h3><p>在嵌入式裸机环境下，有几种方法可以应对内存碎片化问题：</p><ol><li><strong>避免使用堆内存</strong>：遇到需要使用大块内存的地方，可以使用全局数组代替</li><li><strong>实现自定义内存池</strong>：将堆内存空间划分为固定大小的内存块，自己管理与维护内存的申请和释放</li><li><strong>多内存池策略</strong>：将堆内存划分为不同大小的内存块池，根据用户申请内存的大小选择合适的内存块，提高内存利用率</li></ol><h2 id="2-4-FreeRTOS下的堆内存管理"><a href="#2-4-FreeRTOS下的堆内存管理" class="headerlink" title="2.4 FreeRTOS下的堆内存管理"></a>2.4 FreeRTOS下的堆内存管理</h2><p>FreeRTOS提供了多种堆内存管理方案，以适应不同的应用场景：</p><h3 id="2-4-1-FreeRTOS的内存管理方案"><a href="#2-4-1-FreeRTOS的内存管理方案" class="headerlink" title="2.4.1 FreeRTOS的内存管理方案"></a>2.4.1 FreeRTOS的内存管理方案</h3><p>FreeRTOS提供了5种内存管理方案(heap_1.c到heap_5.c)，从简单到复杂，满足不同的需求：</p><ul><li><strong>heap_1</strong>：最简单的实现，只支持内存分配，不支持释放</li><li><strong>heap_2</strong>：支持内存分配和释放，但可能产生碎片</li><li><strong>heap_3</strong>：简单包装了标准C库的malloc和free函数</li><li><strong>heap_4</strong>：支持内存分配和释放，通过合并相邻空闲块减少碎片</li><li><strong>heap_5</strong>：在heap_4的基础上，支持非连续的内存块</li></ul><h3 id="2-4-2-选择合适的内存管理方案"><a href="#2-4-2-选择合适的内存管理方案" class="headerlink" title="2.4.2 选择合适的内存管理方案"></a>2.4.2 选择合适的内存管理方案</h3><p>选择FreeRTOS内存管理方案时，需要考虑以下因素：</p><ul><li>应用对内存的需求</li><li>系统资源的限制</li><li>对内存碎片的容忍度</li><li>实时性要求</li></ul><h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><h2 id="3-1-内存泄漏的概念"><a href="#3-1-内存泄漏的概念" class="headerlink" title="3.1 内存泄漏的概念"></a>3.1 内存泄漏的概念</h2><p>在C函数中，如果使用<code>malloc()</code>等函数申请的内存在使用结束后没有及时被释放，就会造成<strong>内存泄漏</strong>。此时，C标准库中的内存分配器和内核中的内存管理子系统都失去了对这块内存的追踪和管理。</p><p>内存泄漏会导致：</p><ul><li>可用内存逐渐减少</li><li>系统性能下降</li><li>严重时可能导致系统崩溃</li></ul><h2 id="3-2-内存泄漏的预防"><a href="#3-2-内存泄漏的预防" class="headerlink" title="3.2 内存泄漏的预防"></a>3.2 内存泄漏的预防</h2><p>预防内存泄漏的最佳实践：</p><ol><li><strong>配对使用内存操作函数</strong>：内存申请后及时释放，确保<code>malloc()</code>与<code>free()</code>配对使用</li><li><strong>释放内存后置空指针</strong>：内存释放后将指针设置为<code>NULL</code>，避免悬空指针</li><li><strong>使用内存前检查</strong>：使用内存指针前进行非空判断</li><li><strong>采用RAII设计模式</strong>：在C++中可使用智能指针等机制自动管理内存</li><li><strong>使用内存泄漏检测工具</strong>：如Valgrind等工具帮助检测内存泄漏</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文详细介绍了ARM架构下的内存堆栈管理：</p><ol><li><p><strong>栈管理</strong>：</p><ul><li>栈是先进后出的数据结构，由编译器自动管理</li><li>ARM使用满递减栈，SP寄存器指向栈顶元素</li><li>函数调用时创建栈帧，保存局部变量、参数和返回地址</li><li>参数传递优先使用寄存器(R0-R3)，超出部分使用栈</li></ul></li><li><p><strong>堆管理</strong>：</p><ul><li>堆是动态分配的内存，由程序员手动管理</li><li>裸机环境下需要注意内存碎片化问题</li><li>FreeRTOS提供了多种内存管理方案</li></ul></li><li><p><strong>内存泄漏</strong>：</p><ul><li>申请的内存未及时释放会导致内存泄漏</li><li>预防内存泄漏需要配对使用内存操作函数，释放后置空指针</li></ul></li></ol><p>理解内存堆栈管理对于编写高效、稳定的嵌入式程序至关重要。在实际开发中，应根据具体应用场景选择合适的内存管理策略。</p>]]></content>
      
      
      <categories>
          
          <category> ARM架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM架构 </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存布局</title>
      <link href="/_posts/20977/"/>
      <url>/_posts/20977/</url>
      
        <content type="html"><![CDATA[<blockquote><p>建议在阅读本文章之前先阅读以下文章：<br><a href="http://localhost:4000/_posts/59193">程序的编译、链接过程</a></p></blockquote><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ol><li><strong>Flash (ROM&#x2F;Program Memory)</strong>：存储程序代码和常量。</li><li><strong>RAM (Data Memory)</strong>：存储运行时的变量（全局、静态、局部）、堆栈数据。</li><li><strong>链接器脚本 (Linker Script, .ld 文件)</strong>：<br>告诉链接器如何将汇编器生成的各个目标文件中的“段”组合起来，最终映射到物理的 Flash 和 RAM 地址空间。</li><li><strong>启动代码 (Startup Code)</strong>：在 main 函数执行之前运行的初始化代码，负责关键的硬件初始化和最关键的内存初始化（初始化 .data 段，清零 .bss 段，设置堆栈指针）。</li></ol><h1 id="主要的内存段"><a href="#主要的内存段" class="headerlink" title="主要的内存段"></a>主要的内存段</h1><p><img src="/../../img/ARM%E6%9E%B6%E6%9E%84/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80RAM&ROM.png" alt="各个段在内存中的示意图（箭头代表增长方向）"></p><h2 id="1-text-代码段"><a href="#1-text-代码段" class="headerlink" title="1. .text (代码段)"></a>1. .text (代码段)</h2><p><strong>作用</strong>：存储程序的可执行代码（机器指令）</p><p><strong>存储位置</strong>：Flash (ROM)。因为代码是只读的，并且需要掉电后保留。</p><p><strong>实现</strong>：编译器将 C&#x2F;C++&#x2F;汇编代码编译成机器指令</p><ul><li>汇编器&#x2F;编译器将这些指令放入文件的 .text 段</li><li>链接器根据链接脚本将所有目标文件的 .text 段合并，并定位到 Flash 的起始地址（通常是 0x08000000 或类似地址）</li><li>上电复位后，CPU 从 Flash 的 .text 段中取指令执行</li></ul><h2 id="2-data-已初始化数据段"><a href="#2-data-已初始化数据段" class="headerlink" title="2. .data (已初始化数据段)"></a>2. .data (已初始化数据段)</h2><p><strong>作用</strong>：存储已初始化的全局变量和静态变量（包括函数内部的静态变量）。这些变量在程序开始运行时就有一个明确的非零初始值。</p><p><strong>存储位置</strong>：</p><ul><li>初始值存储在 Flash (ROM)：编译器在编译时知道这些变量的初始值，所以这些初始值被当作常量数据存储</li><li>运行时这些变量会被复制到 RAM 中（由启动代码在 main() 执行前完成）</li></ul><p><strong>实现 (关键点)</strong>：</p><ul><li>编译器为每个已初始化的全局&#x2F;静态变量预留 RAM 空间</li><li>编译器将这些变量的初始值提取出来，放入一个特殊的 .data 段（这个 .data 段最终会放在 Flash 中）</li><li>链接脚本做两件重要的事情：<ol><li>定义 .data 段在 RAM 中的运行时起始地址 (_sdata) 和结束地址 (_edata)</li><li>定义 .data 段的初始值在 Flash 中的存储位置 (_sidata)</li></ol></li><li>启动代码 (核心任务之一)：<ul><li>在 main() 执行前，启动代码负责将 Flash 中 _sidata 地址开始的 .data 段初始值数据，复制到 RAM 中 _sdata 地址开始的区域</li><li>复制长度是 _edata - _sdata</li><li>复制完成后，RAM 中的这些变量就有了程序设定的初始值</li></ul></li></ul><p><strong>关键特性</strong>：需要初始化（非零初始值），占用 Flash (存初始值) 和 RAM (存变量本身) 两种空间。启动时必须从 Flash 复制到 RAM。</p><h2 id="3-bss-未初始化数据段"><a href="#3-bss-未初始化数据段" class="headerlink" title="3. .bss (未初始化数据段)"></a>3. .bss (未初始化数据段)</h2><p><strong>作用</strong>：存储未初始化或显式初始化为 0 的全局变量和静态变量。</p><p><strong>存储位置</strong>：RAM。因为这些变量在程序开始运行时没有有效值（或要求为 0），不需要在 Flash 中存储任何初始数据（除了知道它的大小）。</p><p><strong>实现 (关键点)</strong>：</p><ul><li>编译器为每个未初始化或初始化为 0 的全局&#x2F;静态变量预留 RAM 空间</li><li>编译器将这些变量放入 .bss 段。注意：.bss 段本身在最终的程序镜像（烧写到 Flash 的 .bin&#x2F;.hex 文件）中不占据任何实际字节空间！它只记录需要预留多少 RAM 并将其初始化为 0。</li><li>链接器脚本定义 .bss 段在 RAM 中的起始地址 (_sbss) 和结束地址 (_ebss)</li><li>启动代码 (核心任务之二)：<ul><li>在 main() 执行前，启动代码负责将 RAM 中从 _sbss 到 _ebss 的区域清零</li><li>清零长度是 _ebss - _sbss</li></ul></li></ul><p><strong>关键特性</strong>：初始值为零（或未初始化），只占用 RAM 空间，在 Flash 中不存储实际数据（只记录大小）。启动时必须清零。</p><h2 id="4-rodata-段-只读数据段"><a href="#4-rodata-段-只读数据段" class="headerlink" title="4. .rodata 段 (只读数据段)"></a>4. .rodata 段 (只读数据段)</h2><p><strong>作用</strong>：存储常量数据，程序运行期间不会被修改。</p><p><strong>存储位置</strong>：Flash (ROM)。因为是只读的。</p><p><strong>实现</strong>：</p><ul><li>编译器将常量放入 .rodata 段</li><li>链接器将所有 .rodata 段合并并定位到 Flash 的某个区域（通常在 .text 段之后）</li><li>程序运行时直接从 Flash 中读取这些常量数据。有些单片机架构（如 Harvard）不能直接从 Flash 执行数据访问，可能需要特殊指令或临时复制到 RAM，但 .rodata 本身的目标位置是 Flash</li></ul><p><strong>关键特性</strong>：只读，存储在 Flash，不占用 RAM。CPU 直接（或通过特殊方式）从 Flash 读取。</p><h2 id="5-stack（栈区）"><a href="#5-stack（栈区）" class="headerlink" title="5. stack（栈区）"></a>5. stack（栈区）</h2><p><strong>作用</strong>：</p><ul><li>存储局部变量（非静态）</li><li>存储函数调用时的返回地址</li><li>存储函数参数</li><li>保存函数调用前后的寄存器现场</li></ul><p><strong>存储位置</strong>：RAM。需要快速读写。</p><p><strong>实现</strong>：</p><ul><li>通常由链接脚本定义栈的起始地址（栈顶 _estack，通常是 RAM 的最高地址）和大小</li><li>启动代码 (核心任务之三)：设置栈指针寄存器 (SP) 指向链接脚本定义的栈顶地址 _estack</li><li>运行时由 CPU 硬件自动管理（PUSH&#x2F;POP 指令）。函数调用时，局部变量空间在栈上分配；函数返回时，空间自动释放</li><li>栈通常从高地址向低地址增长</li></ul><h2 id="6-heap（堆区）"><a href="#6-heap（堆区）" class="headerlink" title="6. heap（堆区）"></a>6. heap（堆区）</h2><p><strong>作用</strong>：存储动态分配的内存（通过 malloc(), calloc(), new 等分配）</p><p><strong>存储位置</strong>：RAM。需要动态管理。</p><p><strong>实现</strong>：</p><ul><li>链接脚本定义堆的起始地址（通常是 .bss 段结束之后 _end）和大小（_heap_end - _heap_start）</li><li>通常需要实现一个堆内存管理器（如 malloc&#x2F;free 的实现，可能是 newlib 等 C 库提供的，或自定义的）。这个管理器负责在定义的堆区域内分配和回收内存块</li><li>堆通常从低地址向高地址增长（与栈相反），两者在 RAM 中间区域相遇</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th align="left">段名</th><th align="left">存储内容</th><th align="left">主要存储位置</th><th align="left">关键初始化动作(启动代码)</th><th align="left">占用空间类型</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">.text</td><td align="left">程序代码(指令)</td><td align="left">Flash</td><td align="left">无(CPU直接执行)</td><td align="left">Flash</td><td align="left">只读</td></tr><tr><td align="left">.data</td><td align="left">已初始化的全局&#x2F;静态变量</td><td align="left">RAM</td><td align="left">从Flash复制初始值到RAM</td><td align="left">Flash(值)+RAM(变量)</td><td align="left">启动时必须复制</td></tr><tr><td align="left">.bss</td><td align="left">未初始化的全局&#x2F;静态变量(0)</td><td align="left">RAM</td><td align="left">将RAM区域清零</td><td align="left">RAM</td><td align="left">不占Flash空间，启动时必须清零</td></tr><tr><td align="left">.rodata</td><td align="left">常量数据</td><td align="left">Flash</td><td align="left">无(程序直接从Flash读取)</td><td align="left">Flash</td><td align="left">只读</td></tr><tr><td align="left">stack</td><td align="left">局部变量、返回地址、参数等</td><td align="left">RAM</td><td align="left">设置栈指针(SP)</td><td align="left">RAM</td><td align="left">自动管理，向下增长，溢出危险</td></tr><tr><td align="left">heap</td><td align="left">动态分配的内存</td><td align="left">RAM</td><td align="left">初始化堆管理器(可选)</td><td align="left">RAM</td><td align="left">程序员管理(malloc&#x2F;free)，向上增长，碎片风险</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> ARM架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM架构 </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译过程</title>
      <link href="/_posts/59193/"/>
      <url>/_posts/59193/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要了解编译原理"><a href="#为什么要了解编译原理" class="headerlink" title="为什么要了解编译原理"></a>为什么要了解编译原理</h1><p>&emsp;&emsp;在嵌入式开发的世界里，处理器平台和软件生态呈现碎片化、多样化的特点。不同的嵌入式系统往往采用更灵活的配置：不同的CPU平台、不同大小的存储、不同的启动方式。因此，我们不仅要编写代码，还需要考虑将程序代码”烧”写到什么地方、加载到内存什么位置、如何执行——我们必须理解代码从源文件到在特定内存地址运行的完整历程，才能根据硬件平台的差异灵活地完成软件层面的编译优化和配置。</p><h1 id="编译的大概过程"><a href="#编译的大概过程" class="headerlink" title="编译的大概过程"></a>编译的大概过程</h1><p>&emsp;&emsp;编译就是将C程序中定义的函数、变量分类后，分别放置在可执行文件的代码段、数据段和BSS段中；程序中定义的字符串、printf函数打印的字符串常量则放置在只读数据段(.rodata)中。</p><p><img src="/../../img/ARM%E6%9E%B6%E6%9E%84/%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.png" alt="程序的编译、链接过程"></p><p>编译过程主要包含以下几个步骤：</p><ol><li><strong>预处理器</strong>：将源文件main.c经过预处理变为main.i</li><li><strong>编译器</strong>：将预处理后的main.i编译为汇编文件main.s</li><li><strong>汇编器</strong>：将汇编文件main.s编译为目标文件main.o</li><li><strong>链接器</strong>：将各个目标文件main.o、fun.o等链接成可执行文件a.out</li></ol><p><strong>注意</strong>：汇编器生成的目标文件是可重定位的目标文件，本身不可执行，需要经过链接器的链接、重定位之后才能运行。</p><h1 id="编译的具体过程"><a href="#编译的具体过程" class="headerlink" title="编译的具体过程"></a>编译的具体过程</h1><h2 id="预处理（预处理器）"><a href="#预处理（预处理器）" class="headerlink" title="预处理（预处理器）"></a>预处理（预处理器）</h2><p>&emsp;&emsp;预处理过程是在编译源程序之前，先处理源文件中的各种预处理命令。编译器不识别预处理指令，如果在编译前不先处理这些预处理命令，编译器会报错。预处理主要包括以下操作：</p><ul><li><strong>头文件展开</strong>：将<code>#include</code>包含的头文件内容展开到当前位置</li><li><strong>宏展开</strong>：展开所有的宏定义，并删除<code>#define</code>指令</li><li><strong>条件编译</strong>：根据宏定义条件，选择要参与编译的分支代码，其余分支丢弃</li><li><strong>删除注释</strong>：移除代码中的注释内容</li><li><strong>添加行号和文件名标识</strong>：编译过程中根据需要显示这些信息</li><li><strong>保留<code>#pragma</code>命令</strong>：该命令会在程序编译时指示编译器执行一些特定行为</li></ul><h2 id="编译（编译器、汇编器）"><a href="#编译（编译器、汇编器）" class="headerlink" title="编译（编译器、汇编器）"></a>编译（编译器、汇编器）</h2><p>编译阶段主要分为两步：</p><ol><li><strong>编译器</strong>调用一系列解析工具分析C代码，将C源文件编译为汇编文件</li><li><strong>汇编器</strong>将汇编文件汇编成可重定位的目标文件</li></ol><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>C源文件到汇编文件的转换，实际上是将C文件中的程序代码块、函数转换为汇编程序中的代码段，将C程序中的全局变量、静态变量、常量转换为汇编程序中的数据段、只读数据段。</p><p>总体来说，编译过程分为以下六步：</p><ol><li><strong>词法分析</strong>：将源程序分解为一系列不能再分解的记号单元（token）</li><li><strong>语法分析</strong>：对token序列进行解析，构建语法上正确的语法树</li><li><strong>语义分析</strong>：检查语法分析输出的表达式、语句是否存在语义错误（如类型不匹配、未声明变量等）</li><li><strong>中间代码生成</strong>：将语法树转化为中间代码，中间代码是一维线性序列结构，类似伪代码（与平台无关）</li><li><strong>汇编代码生成</strong>：参考ARM指令集，根据ATPCS规则分配寄存器，将中间代码翻译成ARM汇编程序</li><li><strong>目标代码生成</strong>：优化汇编代码，生成最终的目标代码</li></ol><h3 id="汇编过程"><a href="#汇编过程" class="headerlink" title="汇编过程"></a>汇编过程</h3><p>&emsp;&emsp;汇编过程是使用汇编器将前一阶段生成的汇编文件翻译成目标文件。汇编器的主要工作是参考指令集架构（例如ARM Cortex-M的Thumb指令集），将汇编代码翻译成对应的二进制指令，同时生成必要的信息，以section的形式组装到目标文件中，供后续链接过程使用。</p><p>&emsp;&emsp;汇编器处理过后的.o文件是不可执行的，属于可重定位目标文件，需要经过链接器的重定位、链接之后，才能组装成可执行的目标文件。</p><h2 id="符号与重定位的概念"><a href="#符号与重定位的概念" class="headerlink" title="符号与重定位的概念"></a>符号与重定位的概念</h2><p>&emsp;&emsp;编译器在将源文件翻译成可重定位目标文件的过程中，会将不同的函数编译成二进制指令后，从零地址开始依次将每个函数的指令序列存放到代码段中，每个函数的入口地址也就从零地址开始依次往后偏移。因此，在每个可重定位目标文件中，函数或变量的地址其实就是它们在文件中相对于零地址的偏移。</p><p>&emsp;&emsp;然而，在链接过程中，链接器将各个目标文件组装在一起时，各个目标文件的参考起始地址会发生变化，因此目标文件内的函数或变量的地址也需要随之更新，否则我们无法通过函数名引用函数、通过变量名引用变量。这个过程称为<strong>重定位</strong>。</p><p>&emsp;&emsp;一个文件中的所有符号（无论是函数名还是变量名），无论其是否需要重定位，汇编器都会收集起来，生成一个符号表，以section的形式添加到每一个可重定位目标文件中。在整个编译过程中，符号表主要用来保存源程序中各种符号的信息，包括符号的地址、类型、占用空间的大小等。符号表本质上是一个结构体数组，每个符号都有符号值和类型。</p><p>&emsp;&emsp;编译器是以C源文件为单位编译程序的。如果在一个C源文件中引用了在其他文件中定义的函数或全局变量，只要在调用之前进行声明，编译器就会认为这些符号可能在其他文件或库中定义，在编译阶段暂时不会报错。在链接过程中，链接器会尝试在其他文件或库中查找这些符号的定义，如果找不到才会报错（链接错误）。</p><p>&emsp;&emsp;编译器在给每个目标文件生成符号表时，如果在当前文件中没有找到符号的定义，也会将这些符号搜集在一起并保存到一个单独的符号表中，以待后续填充，这个符号表就是<strong>重定位符号表</strong>。重定位表中的符号所关联的地址，在后续链接过程中经过重定位后，会更新为新的实际地址。</p><blockquote><p>总结一下上面说的<br>在C项目的编译过程中，编译器以C源文件为单位，将一个个C文件翻译成对应的目标文件。每个目标文件都由代码段、数据段、BSS段、符号表等section组成。这些section从目标文件的零偏移地址开始按顺序排放，每个段中的符号相对于零地址的偏移，就是每个符号的地址，这样程序中定义的变量、函数名等就有了一个暂时的地址。<br>在链接过程中，这些目标文件中的各个section会重新拆分组装，每个section的起始参考地址都会发生变化，导致每个section中定义的函数、全局变量等符号的地址也需要随之修改，这个过程就是重定位。</p></blockquote><h2 id="链接（链接器）"><a href="#链接（链接器）" class="headerlink" title="链接（链接器）"></a>链接（链接器）</h2><p>链接主要分为三个过程：<strong>分段组装</strong>、<strong>符号决议</strong>、<strong>重定位</strong>。</p><h3 id="分段组装"><a href="#分段组装" class="headerlink" title="分段组装"></a>分段组装</h3><p>&emsp;&emsp;链接器将编译器生成的各个可重定位目标文件重新分解组装：将各个目标文件的代码段放在一起，作为最终可执行文件的代码段；将各个目标文件的数据段放在一起，作为可执行文件的数据段。其他section也会按照同样的方法进行组装，最终生成可执行文件的雏形。</p><p>&emsp;&emsp;链接器会在可执行文件中创建一个全局符号表，收集各个目标文件符号表中的符号并统一存放。此时，可执行文件中的所有符号都有了自己的地址，但这些地址仍然是原来在各个目标文件中的地址（即相对于零地址的偏移）。</p><p>&emsp;&emsp;链接生成的可执行文件最终要被加载到内存中执行，因此需要指定加载到内存中的位置。通常，程序在链接时需要指定一个链接起始地址，这个地址一般就是程序要加载到内存中的地址。在链接过程中，各个段在可执行文件中的先后组装顺序也需要考虑，可执行程序的入口地址部分通常会放在前面。</p><p>&emsp;&emsp;要指定程序的链接地址和各个段的组装顺序，可以通过<strong>链接脚本</strong>实现。链接脚本本质上是一个脚本文件，不仅规定了各个段的组装顺序、起始地址、位置对齐等信息，还详细描述了输出的可执行文件格式、运行平台、入口地址等信息。链接器根据链接脚本定义的规则组装可执行文件，并将这些信息以section的形式保存到可执行文件的ELF Header中。</p><h3 id="符号决议"><a href="#符号决议" class="headerlink" title="符号决议"></a>符号决议</h3><p>&emsp;&emsp;链接器允许一个项目中出现多个弱符号共存。在程序编译期间，编译器分析每个文件中未初始化的全局变量时，不知道该符号在链接阶段是被采用还是被丢弃，因此未初始化的全局变量并没有直接放置在BSS段中，而是将这些弱符号放到一个叫作COMMON的临时块中，在符号表中用未定义的COMMON标记，并且在目标文件中不分配存储空间。</p><p>&emsp;&emsp;在链接期间，链接器会比较多个文件中的弱符号，选择占用空间最大的那个作为可执行文件中的最终符号。此时，弱符号的大小已经确定，并被直接放到可执行文件的BSS段中。</p><p>&emsp;&emsp;与强符号、弱符号对应的，还有强引用、弱引用的概念。在程序中，我们可以定义多个函数和变量，变量名和函数名都是符号，这些符号的本质（符号值）其实就是地址。在另一个文件中，我们可以通过函数名调用函数，通过变量名访问变量。这种通过符号调用函数或访问变量的行为通常称为引用（reference），强符号对应强引用，弱符号对应弱引用。</p><p>&emsp;&emsp;在程序链接过程中，若对一个符号的引用为强引用，链接时找不到其定义，链接器将会报未定义错误；若对一个符号的引用为弱引用，链接时找不到其定义，链接器不会报错，也不会影响最终可执行文件的生成。可执行文件在运行时如果仍然找不到该符号的定义才会报错。</p><h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>&emsp;&emsp;经过符号决议，我们解决了链接过程中多文件符号冲突的问题。此时，可执行文件的符号表中的每个符号虽然都已确定，但符号表中的符号值（即每个函数、全局变量的地址）仍然是原来各个目标文件中的值，基于零地址的偏移。而链接器将各个目标文件重新分解组装后，各个段的起始地址都已发生变化。</p><p>&emsp;&emsp;程序重新分解组装后，无论是代码段还是数据段，各个符号的真实地址都发生了变化。因此，需要修改全局符号表中这些符号的值，将它们的真实地址更新到符号表中。修改完毕后，当我们通过符号引用调用函数或访问变量时，就能找到它们在内存中的真实地址了。</p><p>&emsp;&emsp;链接器如何知道哪些符号需要重定位呢？在各个目标文件中，有一个专门的重定位表，用于记录各个文件中需要重定位的符号。重定位的核心工作就是修正指令中的符号地址，这是链接过程中的最后一步，也是最核心、最重要的一步，前面的操作实际上都是为这一步服务的。</p><p>&emsp;&emsp;在编译阶段，编译器将各个C源文件生成目标文件时，遇到未定义的符号一般不会报错，而是认为这些符号可能在其他地方定义。只有在链接阶段，链接器在其他地方找不到该符号的定义时，才会报链接错误。编译器在编译阶段会搜集这些未定义的符号，生成一个重定位表，用于告诉链接器：”这些符号在文件中被引用，但在本文件中没有找到定义，可能在其他文件或库中定义，我先不报错，你链接的时候找找看”。</p><p>&emsp;&emsp;无论是代码段还是数据段，只要该段中有需要重定位的符号，编译器都会生成一个重定位表与其对应，如.rel.text（代码段重定位表）或.rel.data（数据段重定位表）。这些重定位表记录了各个段中需要重定位的符号，并以section的形式保存在各个目标文件中。</p><blockquote><p>至此，整个链接过程就结束了，我们跟踪的整个编译流程也就完成了。最终生成的文件就是一个可执行目标文件。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ARM架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM架构 </tag>
            
            <tag> 编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Worldd</title>
      <link href="/_posts/42111/"/>
      <url>/_posts/42111/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
